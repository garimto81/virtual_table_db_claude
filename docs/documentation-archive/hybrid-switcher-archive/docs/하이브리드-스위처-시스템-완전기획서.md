# AI 기반 스트림덱 스마트 스위칭 시스템 완전 기획서

## 목차
1. [프로젝트 개요](#1-프로젝트-개요)
2. [AI 시스템 설계](#2-ai-시스템-설계)
3. [스트림덱 연동 시스템](#3-스트림덱-연동-시스템)
4. [기술 구현](#4-기술-구현)
5. [운영 가이드](#5-운영-가이드)
6. [개발 가이드](#6-개발-가이드)
7. [API 문서](#7-api-문서)
8. [개발 프로세스](#8-개발-프로세스)

---

## 1. 프로젝트 개요

### 1.1 프로젝트명
**AI 기반 스트림덱 스마트 스위칭 시스템 (AI-Powered Stream Deck Smart Switching System)**

### 1.2 프로젝트 배경

#### 현황 및 문제점
- **1차원적 스위칭**: 기존 방송 스위칭은 단순한 카메라 전환에 의존
- **게임 이해 부족**: 운영자가 게임 상황을 실시간으로 파악하고 판단해야 함
- **높은 피로도**: 장시간 집중력 유지 필요, 반복적인 수동 작업
- **놓치는 순간들**: 중요한 게임 순간을 예측하지 못해 놓치는 경우 발생

#### 해결 방안
AI가 게임 내용과 흐름을 이해하여 스트림덱을 통해 지능적인 스위칭 제안 및 자동화

### 1.3 프로젝트 정의

#### 핵심 개념
"게임의 맥락을 이해하는 AI가 최적의 스위칭 포인트를 예측하고, 스트림덱을 통해 운영자와 협업하는 차세대 방송 제작 시스템"

#### 주요 특징
- **AI 게임 분석**: 실시간 게임 상황 인식 및 중요 순간 예측
- **스트림덱 통합**: Companion 프로토콜을 통한 직관적 인터페이스
- **스마트 제안**: AI가 최적의 카메라 앵글과 타이밍 제안
- **피로도 최소화**: 자동화와 예측을 통한 운영자 부담 감소

### 1.4 시스템 차별점

| 구분 | 기존 방식 | 하이브리드 스위처 |
|------|-----------|------------------|
| 스위칭 결정 | 운영자 직관 의존 | AI 분석 + 운영자 확인 |
| 게임 이해 | 운영자 경험 필요 | AI가 게임 패턴 학습 |
| 작업 부담 | 모든 결정 수동 | 중요 결정만 수동 |
| 예측 능력 | 제한적 | AI 기반 선제적 준비 |

### 1.5 기대 효과

#### 운영 효율성
- 운영자 피로도 70% 감소
- 중요 순간 포착률 95% 이상
- 스위칭 정확도 향상

#### 방송 품질
- 더 다이나믹한 카메라 워크
- 스토리텔링 강화
- 시청자 몰입도 증가

#### 비즈니스 가치
- 운영 인력 효율화
- 방송 품질 차별화
- 새로운 수익 모델 창출

---

## 2. AI 시스템 설계

### 2.1 AI 게임 분석 엔진

```python
class GameAnalysisEngine:
    def __init__(self):
        self.vision_model = PokerVisionModel()
        self.context_analyzer = GameContextAnalyzer()
        self.prediction_engine = SwitchingPredictor()
    
    def analyze_game_state(self, video_stream):
        # 게임 상태 실시간 분석
        game_state = self.vision_model.detect_game_elements(video_stream)
        context = self.context_analyzer.understand_situation(game_state)
        predictions = self.prediction_engine.predict_key_moments(context)
        return predictions
```

#### 주요 기능
- **플레이어 감정 분석**: 표정, 몸짓을 통한 텐션 감지
- **카드 및 칩 인식**: 게임 진행 상황 실시간 추적
- **팟 사이즈 모니터링**: 중요도 판단 기준
- **베팅 패턴 분석**: 플레이어별 성향 학습

### 2.2 상황별 중요도 알고리즘

```yaml
priority_levels:
  critical:
    - all_in_situation: 95
    - final_table_elimination: 90
    - big_pot_showdown: 85
  
  high:
    - significant_raise: 75
    - player_reaction: 70
    - dealer_action: 65
  
  medium:
    - routine_betting: 45
    - card_dealing: 40
    - break_time: 30
```

### 2.3 스위칭 예측 시스템

#### 예측 모델 아키텍처
```
Input Layer (게임 데이터)
    ↓
Context Understanding (LSTM)
    ↓
Pattern Recognition (CNN)
    ↓
Temporal Analysis (Transformer)
    ↓
Switching Prediction (Classification)
    ↓
Confidence Score (0-100%)
```

#### 실시간 예측 프로세스
1. **상황 분석**: 현재 게임 상태 파악
2. **패턴 매칭**: 유사 상황 데이터베이스 검색
3. **확률 계산**: 다음 중요 순간 발생 확률
4. **타이밍 예측**: 최적 스위칭 포인트 계산
5. **신뢰도 평가**: 예측 정확도 자체 평가

### 2.4 학습 및 적응 시스템

```python
class OperatorPreferenceLearning:
    def __init__(self):
        self.preference_model = UserPreferenceModel()
        self.feedback_processor = FeedbackProcessor()
    
    def learn_from_actions(self, ai_suggestion, operator_action):
        # 운영자의 실제 선택으로부터 학습
        feedback = self.analyze_decision_difference(ai_suggestion, operator_action)
        self.preference_model.update(feedback)
        return self.preference_model.get_personalized_weights()
```

#### 지속적 개선 메커니즘
- **실시간 피드백**: 운영자 승인/거부 데이터 수집
- **결과 분석**: 방송 품질 지표와 AI 예측 정확도 상관관계 분석
- **모델 업데이트**: 주간 단위 모델 재학습
- **A/B 테스트**: 새로운 알고리즘의 단계적 도입

---

## 3. 스트림덱 연동 시스템

### 3.1 Companion 프로토콜 통합

#### Companion 연동 아키텍처
```javascript
// Companion 모듈 구조
const CompanionModule = {
    id: 'hybrid-switcher',
    label: 'Hybrid Switcher AI',
    version: '1.0.0',
    
    // AI 시스템과의 WebSocket 연결
    websocket: {
        host: 'localhost',
        port: 8080,
        protocol: 'ws'
    },
    
    // 스트림덱 버튼 정의
    actions: {
        ai_suggestion_accept: 'AI 제안 승인',
        ai_suggestion_reject: 'AI 제안 거부',
        manual_override: '수동 오버라이드',
        priority_boost: '우선순위 상승'
    }
}
```

### 3.2 스트림덱 UI 설계

#### 버튼 레이아웃
```
┌─────────────────────────────────────┐
│ [AI ON]  [학습]  [설정]  [통계]     │  1행: 시스템 제어
├─────────────────────────────────────┤
│ [수락]  [거부]  [지연]  [수동]     │  2행: AI 제안 응답
├─────────────────────────────────────┤
│ [CAM1]  [CAM2]  [CAM3]  [CAM4]     │  3행: 카메라 직접 제어
├─────────────────────────────────────┤
│ [와이드] [클로즈] [오버헤드] [특수] │  4행: 프리셋 앵글
└─────────────────────────────────────┘
```

#### 동적 버튼 상태
```javascript
button_states: {
    accept: {
        color: "green",
        text: "수락 (87%)",
        blink: true,
        countdown: 10  // 10초 후 자동 실행
    },
    reject: {
        color: "red", 
        text: "거부",
        blink: false
    }
}
```

### 3.3 사용자 경험 최적화

#### 인지 부담 최소화
- **시각적 우선순위**: 중요도에 따른 버튼 크기/색상 조절
- **예측 표시**: 다음 가능한 액션 미리 표시
- **컨텍스트 정보**: 게임 상황 요약 정보 제공
- **원클릭 승인**: 신뢰도 높은 제안은 즉시 실행 가능

#### 피드백 시스템
```python
class FeedbackSystem:
    def __init__(self):
        self.haptic_feedback = HapticController()
        self.visual_feedback = LEDController()
        self.audio_feedback = AudioController()
    
    def provide_confirmation(self, action_type, success_rate):
        # 햅틱 피드백
        if success_rate > 90:
            self.haptic_feedback.short_pulse()
        elif success_rate > 70:
            self.haptic_feedback.double_pulse()
        else:
            self.haptic_feedback.warning_pattern()
```

---

## 4. 기술 구현

### 4.1 시스템 아키텍처

#### 전체 시스템 구조
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Video Input   │───▶│   AI Analysis   │───▶│  Stream Deck    │
│                 │    │     Engine      │    │   Controller    │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ • 멀티 카메라    │    │ • 게임 상태 AI   │    │ • Companion     │
│ • 오디오 피드    │    │ • 예측 모델      │    │ • 버튼 매니저    │
│ • 메타데이터     │    │ • 학습 시스템    │    │ • 피드백 시스템  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 ▼
                    ┌─────────────────┐
                    │  Broadcasting   │
                    │     System      │
                    │ • OBS Studio    │
                    │ • ATEM/vMix     │
                    └─────────────────┘
```

### 4.2 마이크로서비스 구조

```yaml
services:
  ai-vision-service:
    image: hybrid-switcher/ai-vision:latest
    ports: ["8001:8001"]
    gpu: required
    
  game-context-service:
    image: hybrid-switcher/game-context:latest
    ports: ["8002:8002"]
    
  prediction-service:
    image: hybrid-switcher/prediction:latest
    ports: ["8003:8003"]
    
  companion-bridge:
    image: hybrid-switcher/companion-bridge:latest
    ports: ["8080:8080"]
    
  data-processor:
    image: hybrid-switcher/data-processor:latest
    volumes: ["./data:/app/data"]
```

### 4.3 AI 모델 구현

#### 비전 모델 (YOLO + Custom Training)
```python
import torch
import torch.nn as nn
from torchvision import transforms

class PokerVisionModel(nn.Module):
    def __init__(self, num_classes=50):  # 카드, 칩, 플레이어 등
        super().__init__()
        self.backbone = self.load_yolo_backbone()
        self.poker_head = nn.Sequential(
            nn.Conv2d(1024, 512, 3, padding=1),
            nn.ReLU(),
            nn.Conv2d(512, num_classes, 1)
        )
        
    def forward(self, x):
        features = self.backbone(x)
        detections = self.poker_head(features)
        return self.post_process(detections)
```

#### 게임 상황 이해 모델 (Transformer)
```python
class GameContextTransformer(nn.Module):
    def __init__(self, d_model=512, num_heads=8, num_layers=6):
        super().__init__()
        self.positional_encoding = PositionalEncoding(d_model)
        self.transformer = nn.TransformerEncoder(
            nn.TransformerEncoderLayer(d_model, num_heads),
            num_layers
        )
        self.context_classifier = nn.Linear(d_model, 20)  # 20가지 상황 타입
        
    def forward(self, game_sequence):
        # 게임 이벤트 시퀀스를 입력받아 상황 분석
        embedded = self.positional_encoding(game_sequence)
        context_features = self.transformer(embedded)
        situation = self.context_classifier(context_features[-1])
        return situation
```

### 4.4 실시간 처리 시스템

#### 스트리밍 파이프라인
```python
import asyncio
import cv2
from aiortc import VideoStreamTrack

class VideoAnalysisTrack(VideoStreamTrack):
    def __init__(self, source):
        super().__init__()
        self.source = source
        self.ai_model = PokerVisionModel()
        self.frame_buffer = asyncio.Queue(maxsize=30)
        
    async def recv(self):
        frame = await self.source.recv()
        
        # 비동기 AI 분석
        asyncio.create_task(self.analyze_frame(frame))
        
        return frame
        
    async def analyze_frame(self, frame):
        # GPU에서 병렬 처리
        analysis_result = await self.ai_model.async_inference(frame)
        await self.send_to_decision_engine(analysis_result)
```

### 4.5 성능 최적화

#### GPU 가속 처리
```python
import torch
import torch.nn as nn
from torch.cuda.amp import autocast, GradScaler

class OptimizedInference:
    def __init__(self, model):
        self.model = model.cuda()
        self.model.eval()
        self.scaler = GradScaler()
        
        # TensorRT 최적화
        self.model = torch.jit.script(self.model)
        
    @torch.no_grad()
    async def async_inference(self, batch):
        with autocast():
            # 반정밀도 연산으로 속도 향상
            results = self.model(batch.cuda())
            return results.cpu()
```

---

## 5. 운영 가이드

### 5.1 시스템 설치 및 설정

#### 하드웨어 요구사항

**최소 사양**
- CPU: Intel i7-10700K 또는 AMD Ryzen 7 3700X
- GPU: NVIDIA RTX 3060 12GB (CUDA 필수)
- RAM: 32GB DDR4
- Storage: 1TB NVMe SSD
- Network: 1Gb Ethernet

**권장 사양**
- CPU: Intel i9-12900K 또는 AMD Ryzen 9 5900X
- GPU: NVIDIA RTX 4070 Ti 이상
- RAM: 64GB DDR4
- Storage: 2TB NVMe SSD + 4TB HDD
- Network: 10Gb Ethernet

#### 소프트웨어 설치
```bash
# Docker 환경 설정
git clone https://github.com/hybrid-switcher/ai-switching-system.git
cd ai-switching-system

# 환경 설정
cp .env.example .env
nano .env  # AI 모델 경로, GPU 설정 등 구성

# CUDA 및 PyTorch 설치
pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118

# 시스템 빌드 및 실행
docker-compose up -d

# Companion 플러그인 설치
cd companion-plugin
npm install
npm run build
```

### 5.2 일상 운영

#### 방송 시작 전 체크리스트
```
□ AI 시스템 상태 확인 (GPU 사용률 < 80%)
□ 카메라 연결 상태 점검 (모든 카메라 Active)
□ Stream Deck 연결 확인 (Companion 연결됨)
□ 오디오 레벨 체크 (입력 신호 정상)
□ 모델 로딩 완료 (Warm-up 3분 대기)
□ 캘리브레이션 실행 (테이블 레이아웃 인식)
```

#### AI 모드별 운영

**자동 모드 (Confidence > 85%)**
- AI가 직접 스위칭 실행
- 운영자는 모니터링만 수행
- 긴급 상황 시 수동 개입 가능

**협업 모드 (Confidence 60-85%)**
- AI가 제안, 운영자가 승인/거부
- Stream Deck 버튼으로 즉시 응답
- 5초 내 무응답 시 자동 실행

**수동 모드 (Confidence < 60%)**
- 전통적인 수동 스위칭
- AI는 정보 제공만 수행
- 학습 데이터 수집 지속

### 5.3 문제 해결

#### AI 예측 정확도 저하
```
증상: 예측 신뢰도가 평소보다 낮음
원인: 게임 환경 변화, 조명 조건 변화
해결:
1. 캘리브레이션 재실행
2. 환경 적응 모드 활성화
3. 수동 라벨링으로 추가 학습 데이터 생성
```

#### Stream Deck 연결 끊김
```
증상: 버튼 입력이 AI 시스템에 전달되지 않음
원인: Companion 연결 오류, 네트워크 지연
해결:
1. Companion 서비스 재시작
2. 네트워크 연결 확인
3. 백업 컨트롤 인터페이스 활성화
```

---

## 6. 개발 가이드

### 6.1 개발 환경 설정

```bash
# Python 개발 환경
pyenv install 3.11.0
pyenv global 3.11.0
pip install poetry

# Node.js 개발 환경 (Companion 플러그인용)
nvm install 18.17.0
nvm use 18.17.0
npm install -g typescript @types/node

# GPU 개발 환경
conda create -n hybrid-switcher python=3.11
conda activate hybrid-switcher
conda install pytorch torchvision torchaudio pytorch-cuda=11.8 -c pytorch -c nvidia
```

### 6.2 프로젝트 구조

```
hybrid-switcher/
├── ai-engine/                 # AI 모델 및 추론 엔진
│   ├── models/               # PyTorch 모델 정의
│   ├── training/             # 학습 스크립트
│   ├── inference/            # 실시간 추론 서비스
│   └── data/                 # 데이터 처리 유틸리티
├── companion-plugin/         # Stream Deck Companion 플러그인
│   ├── src/                  # TypeScript 소스
│   ├── assets/               # 아이콘, 이미지
│   └── config/               # 플러그인 설정
├── bridge-service/           # AI 엔진과 Companion 간 브리지
├── web-interface/            # 웹 기반 관리 인터페이스
├── docs/                     # 문서
├── tests/                    # 테스트 코드
└── deployment/               # 배포 스크립트
```

### 6.3 AI 모델 개발

#### 새로운 게임 모델 추가
```python
# ai-engine/models/base_game_model.py
from abc import ABC, abstractmethod
import torch.nn as nn

class BaseGameModel(nn.Module, ABC):
    """게임별 AI 모델의 기본 클래스"""
    
    def __init__(self, config):
        super().__init__()
        self.config = config
        self.setup_architecture()
        
    @abstractmethod
    def setup_architecture(self):
        """모델 아키텍처 정의"""
        pass
        
    @abstractmethod
    def extract_game_state(self, frame):
        """프레임에서 게임 상태 추출"""
        pass
        
    @abstractmethod
    def predict_switch_timing(self, game_state, history):
        """스위칭 타이밍 예측"""
        pass
```

### 6.4 Companion 플러그인 개발

```typescript
// companion-plugin/src/index.ts
import { InstanceBase, InstanceStatus, SomeCompanionConfigField } from '@companion-module/base'

interface HybridSwitcherConfig {
    host: string
    port: number
    ai_enabled: boolean
    confidence_threshold: number
}

class HybridSwitcherInstance extends InstanceBase<HybridSwitcherConfig> {
    private aiConnection: WebSocket | null = null
    private currentSuggestion: AISuggestion | null = null
    
    async init(config: HybridSwitcherConfig): Promise<void> {
        this.config = config
        this.updateStatus(InstanceStatus.Connecting)
        
        // AI 서비스 연결
        await this.connectToAIService()
        
        // 액션 및 피드백 초기화
        this.initActions()
        this.initFeedbacks()
        this.initPresets()
        
        this.updateStatus(InstanceStatus.Ok)
    }
}
```

---

## 7. API 문서

### 7.1 WebSocket API

#### 연결 설정
```javascript
// Companion에서 AI 서비스 연결
const ws = new WebSocket('ws://localhost:8080/ws/companion')

ws.onopen = () => {
    // 인증 및 초기 설정
    ws.send(JSON.stringify({
        type: 'auth',
        token: 'companion_auth_token',
        client_type: 'companion'
    }))
}
```

#### AI 제안 메시지
```json
{
    "type": "ai_suggestion",
    "timestamp": "2025-08-01T10:30:45.123Z",
    "id": "suggestion_12345",
    "data": {
        "action": "camera_switch",
        "target": {
            "camera_id": "cam_player_3",
            "preset": "closeup",
            "transition": "cut"
        },
        "confidence": 0.87,
        "reasoning": {
            "primary_factor": "significant_raise_detected",
            "supporting_factors": [
                "player_tension_high",
                "pot_size_large"
            ],
            "situation_context": "river_betting"
        },
        "timing": {
            "execute_at": "immediate",
            "timeout_seconds": 8,
            "auto_execute": true
        }
    }
}
```

### 7.2 REST API

#### 인증
```http
POST /api/v1/auth/login
Content-Type: application/json

{
    "username": "operator1",
    "password": "secure_password"
}

Response:
{
    "access_token": "eyJhbGciOiJIUzI1NiIs...",
    "refresh_token": "eyJhbGciOiJIUzI1NiIs...",
    "expires_in": 3600,
    "token_type": "Bearer"
}
```

#### 성능 메트릭 조회
```http
GET /api/v1/analytics/performance
Authorization: Bearer {access_token}
Query Parameters:
- start_date: 2025-08-01
- end_date: 2025-08-07
- granularity: daily

Response:
{
    "metrics": [
        {
            "date": "2025-08-01",
            "ai_suggestions": {
                "total": 450,
                "accepted": 387,
                "rejected": 63,
                "acceptance_rate": 0.86
            },
            "performance": {
                "avg_inference_time_ms": 42,
                "accuracy_score": 0.91,
                "operator_satisfaction": 4.2
            }
        }
    ]
}
```

---

## 8. 개발 프로세스

### 8.1 개발 로드맵

#### 총 개발 기간: 15-21주 (4-5개월)

#### 필요 인력: 5명
- AI 엔지니어 2명 (비전 모델, 예측 모델)
- Backend 개발자 1명 (브리지 서비스, API)
- Frontend 개발자 1명 (Companion 플러그인, UI)
- DevOps 엔지니어 1명 (인프라, 배포)

### 8.2 개발 단계

#### Phase 1: 프로젝트 기반 구축 (2주)
**Week 1-2: 개발 환경 구축**
```bash
# 저장소 설정
git init hybrid-switcher-ai
cd hybrid-switcher-ai

# 프로젝트 구조 생성
mkdir -p {ai-engine,companion-plugin,bridge-service,web-interface,tests,docs,deployment}

# Python 환경 (AI 엔진)
pyenv install 3.11.0
pyenv local 3.11.0
pip install poetry

# Node.js 환경 (Companion 플러그인)
nvm install 18.17.0
nvm use 18.17.0
```

#### Phase 2: AI 모델 개발 (4-6주)
**Week 3-4: 데이터 수집 및 전처리**
```python
class DataCollectionPipeline:
    def __init__(self):
        self.video_sources = []
        self.annotation_tools = AnnotationTool()
        
    def collect_poker_videos(self):
        """포커 게임 영상 수집"""
        sources = [
            "twitch_poker_streams",
            "youtube_poker_content", 
            "recorded_live_games"
        ]
        return self.download_and_process(sources)
```

**Week 5-6: 비전 모델 개발**
```python
class PokerVisionModel(nn.Module):
    def __init__(self):
        super().__init__()
        # YOLOv8 백본 사용
        self.backbone = YOLO('yolov8n.pt')
        self.poker_head = self.build_poker_detection_head()
```

**Week 7-8: 게임 상황 이해 및 예측 모델**
```python
class GameContextTransformer(nn.Module):
    def __init__(self, d_model=512):
        super().__init__()
        self.transformer = nn.TransformerEncoder(
            nn.TransformerEncoderLayer(d_model, nhead=8),
            num_layers=6
        )
```

#### Phase 3: Companion 플러그인 개발 (3-4주)
**Week 9-10: 플러그인 기본 구조**
```typescript
export class HybridSwitcherInstance extends InstanceBase<Config> {
    private aiConnection: WebSocket | null = null
    private currentSuggestion: AISuggestion | null = null
    
    async init(config: Config): Promise<void> {
        this.config = config
        await this.connectToAIService()
        this.initActions()
        this.initFeedbacks()
    }
}
```

**Week 11-12: 동적 UI 및 피드백 시스템**
```typescript
class ButtonManager {
    updateSuggestionButtons(suggestion: AISuggestion): void {
        const confidenceColor = this.getConfidenceColor(suggestion.confidence)
        
        this.setButtonState('accept_suggestion', {
            text: `수락 ${Math.round(suggestion.confidence * 100)}%`,
            bgcolor: confidenceColor,
            blink: suggestion.confidence > 0.9
        })
    }
}
```

#### Phase 4: 통합 시스템 개발 (3-4주)
**Week 13-14: 브리지 서비스 개발**
```python
class BridgeService:
    def __init__(self):
        self.ai_client = AIEngineClient()
        self.companion_connections = set()
        
    async def handle_companion_connection(self, websocket: WebSocket):
        await websocket.accept()
        self.companion_connections.add(websocket)
```

**Week 15-16: 실시간 처리 파이프라인**
```python
class RealTimeProcessor:
    async def process_video_stream(self, video_source):
        """실시간 비디오 스트림 처리"""
        cap = cv2.VideoCapture(video_source)
        
        while cap.isOpened():
            ret, frame = cap.read()
            if not ret:
                break
                
            # 비동기 AI 추론
            future = self.executor.submit(self.ai_model.inference, frame)
            asyncio.create_task(self.handle_inference_result(future))
```

#### Phase 5: 테스트 및 최적화 (2-3주)
**Week 17-18: 성능 테스트 및 최적화**
```python
class TestAIModels:
    def test_prediction_latency(self):
        model = PokerVisionModel().cuda()
        dummy_input = torch.randn(1, 3, 720, 1280).cuda()
        
        # 성능 측정
        avg_time = measure_inference_time(model, dummy_input)
        assert avg_time < 0.05  # 50ms 이하
```

#### Phase 6: 배포 및 운영 (1-2주)
**Week 19-20: 프로덕션 배포**
```yaml
# CI/CD 파이프라인
name: Deploy
on:
  push:
    branches: [main]

jobs:
  deploy:
    steps:
      - name: Run tests
        run: |
          python -m pytest ai-engine/tests/
          npm test --prefix companion-plugin
          
      - name: Build containers
        run: docker-compose build
        
      - name: Deploy to production
        run: docker-compose -f docker-compose.prod.yml up -d
```

### 8.3 성공 기준

#### 기술적 목표
- AI 예측 정확도: 85% 이상
- 시스템 응답 시간: 50ms 이하
- 가동률: 99.9% 이상

#### 비즈니스 목표
- 운영자 피로도: 70% 감소
- 방송 품질 향상: 측정 가능한 지표
- 사용자 만족도: 4.5/5.0 이상

### 8.4 개발 일정 요약

| Phase | 기간 | 주요 산출물 | 리소스 |
|-------|------|-------------|---------|
| Phase 1 | 2주 | 개발환경, 기본 구조 | 1명 (DevOps) |
| Phase 2 | 4-6주 | AI 모델, 학습 파이프라인 | 2명 (AI 엔지니어) |
| Phase 3 | 3-4주 | Companion 플러그인 | 1명 (Frontend) |
| Phase 4 | 3-4주 | 통합 시스템, 브리지 | 1명 (Backend) |
| Phase 5 | 2-3주 | 테스트, 최적화 | 전체 팀 |
| Phase 6 | 1-2주 | 배포, 운영 | 1명 (DevOps) |

---

## 9. 프로젝트 요약

### 9.1 핵심 혁신
- **AI 게임 이해**: 단순 영상 인식을 넘어 게임의 맥락과 흐름을 이해
- **스트림덱 협업**: AI와 인간 운영자의 완벽한 협업 인터페이스
- **적응형 학습**: 운영자 선호도를 학습하여 개인화된 제안
- **실시간 예측**: 중요한 순간을 미리 예측하여 준비

### 9.2 기대 성과
- **운영 효율**: 피로도 70% 감소, 정확도 95% 이상
- **방송 품질**: 다이나믹한 연출, 몰입도 향상
- **비즈니스**: 새로운 수익 모델, 시장 차별화

### 9.3 확장 가능성
- 다양한 카드 게임 지원 (블랙잭, 바카라 등)
- e스포츠 및 일반 스포츠 중계로 확장
- 클라우드 기반 SaaS 서비스 제공

---

## 부록

### A. 용어 정의
- **Last Aggressor**: 가장 최근에 공격적 베팅을 한 플레이어
- **Companion**: Elgato Stream Deck의 오픈소스 제어 소프트웨어
- **Confidence Score**: AI 예측의 신뢰도 (0-100%)
- **Auto-execute**: 설정된 시간 후 자동으로 AI 제안 실행

### B. 참고 자료
- [Companion 공식 문서](https://github.com/bitfocus/companion)
- [PyTorch 문서](https://pytorch.org/docs/)
- [Stream Deck SDK](https://developer.elgato.com/documentation/stream-deck/)

### C. 연락처
- 프로젝트 매니저: pm@hybrid-switcher.com
- 기술 지원: support@hybrid-switcher.com
- GitHub: https://github.com/hybrid-switcher

---

**문서 버전**: 2.0.0  
**작성일**: 2025-08-01  
**최종 수정일**: 2025-08-01