<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>íŒŸ ê³„ì‚° í…ŒìŠ¤íŠ¸</title>
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; background: #1a1a1a; color: white; padding: 20px; }
        .test-case { background: #333; border-radius: 8px; padding: 15px; margin: 20px 0; }
        .test-case h3 { color: #fbbf24; margin: 0 0 10px 0; }
        .actions { background: #222; padding: 10px; border-radius: 4px; margin: 10px 0; }
        .action-line { color: #9ca3af; margin: 5px 0; }
        .result { background: #2d3748; padding: 10px; border-radius: 4px; margin-top: 10px; }
        .expected { color: #10b981; }
        .actual { color: #3b82f6; }
        .error { color: #ef4444; }
        .success { color: #10b981; }
        button { background: #4b5563; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { background: #6b7280; }
    </style>
</head>
<body>
    <h1>ğŸ² í¬ì»¤ íŒŸ ê³„ì‚° ë¡œì§ í…ŒìŠ¤íŠ¸</h1>
    
    <div class="test-case" id="test1">
        <h3>í…ŒìŠ¤íŠ¸ 1: ë¦¬ë²„ì—ì„œ ë ˆì´ì¦ˆ-í´ë“œ ì‹œë‚˜ë¦¬ì˜¤</h3>
        <div class="scenario">
            <p>ì´ˆê¸° íŒŸ: 30,000</p>
            <p>Player A: Bet 6,000</p>
            <p>Player B: Raise 26,000</p>
            <p>Player A: Fold</p>
        </div>
        <div class="result">
            <p class="expected">âœ… ì˜ˆìƒ íŒŸ: 36,000 (30,000 + Aì˜ 6,000)</p>
            <p class="actual">ğŸ“Š ê³„ì‚° ê²°ê³¼: <span id="result1"></span></p>
        </div>
    </div>
    
    <div class="test-case" id="test2">
        <h3>í…ŒìŠ¤íŠ¸ 2: ë©€í‹°ì›¨ì´ íŒŸ with í´ë“œ</h3>
        <div class="scenario">
            <p>SB: 50 / BB: 100</p>
            <p>Player A (UTG): Raise 300</p>
            <p>Player B (BTN): Call 300</p>
            <p>Player C (SB): Call 300</p>
            <p>Player D (BB): Call 300</p>
            <p>FLOP:</p>
            <p>Player C: Check</p>
            <p>Player D: Bet 600</p>
            <p>Player A: Fold</p>
            <p>Player B: Fold</p>
            <p>Player C: Call 600</p>
        </div>
        <div class="result">
            <p class="expected">âœ… ì˜ˆìƒ íŒŸ: 2,400 (í”„ë¦¬í”Œë 1,200 + í”Œë 1,200)</p>
            <p class="actual">ğŸ“Š ê³„ì‚° ê²°ê³¼: <span id="result2"></span></p>
        </div>
    </div>
    
    <div class="test-case" id="test3">
        <h3>í…ŒìŠ¤íŠ¸ 3: ì˜¬ì¸ with ì–¸ì½œ ë² íŒ…</h3>
        <div class="scenario">
            <p>í˜„ì¬ íŒŸ: 1,000</p>
            <p>Player A: Bet 500</p>
            <p>Player B: All-in 3,000</p>
            <p>Player A: Fold</p>
        </div>
        <div class="result">
            <p class="expected">âœ… ì˜ˆìƒ íŒŸ: 1,500 (1,000 + Aì˜ 500)</p>
            <p class="expected">âœ… ì–¸ì½œ ë² íŒ…: 2,500 ë°˜í™˜</p>
            <p class="actual">ğŸ“Š ê³„ì‚° ê²°ê³¼: <span id="result3"></span></p>
        </div>
    </div>
    
    <div class="test-case" id="test4">
        <h3>í…ŒìŠ¤íŠ¸ 4: Pot Correction ì‚¬ìš©</h3>
        <div class="scenario">
            <p>PREFLOP: ì—¬ëŸ¬ ì•¡ì…˜ìœ¼ë¡œ íŒŸ 500</p>
            <p>FLOP: Pot Correction 1,000</p>
            <p>FLOP: Player A Bet 200</p>
            <p>FLOP: Player B Call 200</p>
        </div>
        <div class="result">
            <p class="expected">âœ… ì˜ˆìƒ íŒŸ: 1,400 (Correction 1,000 + 400)</p>
            <p class="actual">ğŸ“Š ê³„ì‚° ê²°ê³¼: <span id="result4"></span></p>
        </div>
    </div>
    
    <button onclick="runAllTests()">ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰</button>
    <button onclick="location.href='index.html'">ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</button>
    
    <script>
        // í…ŒìŠ¤íŠ¸ìš© ìƒíƒœ ê°ì²´
        function createTestState(scenario) {
            return {
                actionState: scenario.actionState,
                playersInHand: scenario.players,
                playerStatus: scenario.playerStatus || {}
            };
        }
        
        // í¬ë§·íŒ… í•¨ìˆ˜ë“¤
        function unformatNumber(str) {
            if (!str) return '';
            return String(str).replace(/,/g, '');
        }
        
        function formatNumber(num) {
            if (!num && num !== 0) return '';
            return Number(num).toLocaleString('en-US');
        }
        
        // íŒŸ ê³„ì‚° í•¨ìˆ˜ë“¤ (ë©”ì¸ íŒŒì¼ì—ì„œ ë³µì‚¬)
        function calculatePlayerContributions(state) {
            const contributions = {};
            
            ['preflop', 'flop', 'turn', 'river'].forEach(street => {
                const actions = state.actionState[street] || [];
                
                actions.forEach(action => {
                    if(action.amount && action.player && action.action !== 'Pot Correction') {
                        const player = action.player;
                        const amount = parseInt(unformatNumber(action.amount), 10);
                        contributions[player] = (contributions[player] || 0) + amount;
                    }
                });
            });
            
            return contributions;
        }
        
        function calculateUncalledBet(state) {
            const contributions = calculatePlayerContributions(state);
            const activePlayers = state.playersInHand.filter(p => 
                state.playerStatus[p.name] !== 'folded'
            );
            
            if(activePlayers.length === 1) {
                const winner = activePlayers[0];
                const winnerContribution = contributions[winner.name] || 0;
                
                const otherMaxContribution = Math.max(
                    ...Object.entries(contributions)
                        .filter(([player]) => player !== winner.name)
                        .map(([_, amount]) => amount),
                    0
                );
                
                const uncalledAmount = Math.max(0, winnerContribution - otherMaxContribution);
                
                return {
                    amount: uncalledAmount,
                    player: winner.name
                };
            }
            
            return { amount: 0, player: null };
        }
        
        function calculateActualPot(state) {
            let totalPot = 0;
            let potCorrectionFound = false;
            let potCorrectionValue = 0;
            
            // ë¸”ë¼ì¸ë“œì™€ ì•¤í‹° ì¶”ê°€
            totalPot += parseInt(unformatNumber(state.actionState.smallBlind) || 0, 10);
            totalPot += parseInt(unformatNumber(state.actionState.bigBlind) || 0, 10);
            if(state.actionState.hasBBAnte) {
                totalPot += parseInt(unformatNumber(state.actionState.bigBlind) || 0, 10);
            }
            
            // ëª¨ë“  ìŠ¤íŠ¸ë¦¬íŠ¸ì˜ ì•¡ì…˜ í•©ì‚°
            let correctionStreetIndex = -1;
            const streets = ['preflop', 'flop', 'turn', 'river'];
            
            streets.forEach((street, index) => {
                const actions = state.actionState[street] || [];
                
                // Pot Correction í™•ì¸
                const potCorrection = actions.find(a => a.action === 'Pot Correction');
                if(potCorrection && correctionStreetIndex === -1) {
                    potCorrectionFound = true;
                    potCorrectionValue = parseInt(unformatNumber(potCorrection.amount), 10);
                    correctionStreetIndex = index;
                    totalPot = potCorrectionValue;
                    
                    // Correction ì´í›„ ê°™ì€ ìŠ¤íŠ¸ë¦¬íŠ¸ì˜ ì•¡ì…˜ë“¤ ì¶”ê°€
                    const correctionIdx = actions.indexOf(potCorrection);
                    for(let i = correctionIdx + 1; i < actions.length; i++) {
                        if(actions[i].amount) {
                            totalPot += parseInt(unformatNumber(actions[i].amount), 10);
                        }
                    }
                } else if(correctionStreetIndex === -1) {
                    // Pot Correction ì „ê¹Œì§€ëŠ” ëª¨ë“  ì•¡ì…˜ í•©ì‚°
                    actions.forEach(action => {
                        if(action.amount && action.action !== 'Pot Correction') {
                            totalPot += parseInt(unformatNumber(action.amount), 10);
                        }
                    });
                } else if(index > correctionStreetIndex) {
                    // Correction ì´í›„ ìŠ¤íŠ¸ë¦¬íŠ¸ì˜ ëª¨ë“  ì•¡ì…˜ ì¶”ê°€
                    actions.forEach(action => {
                        if(action.amount) {
                            totalPot += parseInt(unformatNumber(action.amount), 10);
                        }
                    });
                }
            });
            
            // ì–¸ì½œ ë² íŒ… ì œì™¸
            const uncalledBet = calculateUncalledBet(state);
            return totalPot - uncalledBet.amount;
        }
        
        // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë“¤
        const testCases = {
            test1: {
                actionState: {
                    smallBlind: '0',
                    bigBlind: '0',
                    preflop: [],
                    flop: [],
                    turn: [],
                    river: [
                        { action: 'Pot Correction', amount: '30000' },
                        { player: 'A', action: 'Bets', amount: '6000' },
                        { player: 'B', action: 'Raises', amount: '26000' },
                        { player: 'A', action: 'Folds', amount: null }
                    ]
                },
                players: [
                    { name: 'A' },
                    { name: 'B' }
                ],
                playerStatus: {
                    'A': 'folded',
                    'B': 'active'
                },
                expected: 36000
            },
            test2: {
                actionState: {
                    smallBlind: '50',
                    bigBlind: '100',
                    preflop: [
                        { player: 'A', action: 'Raises', amount: '300' },
                        { player: 'B', action: 'Calls', amount: '300' },
                        { player: 'C', action: 'Calls', amount: '300' },
                        { player: 'D', action: 'Calls', amount: '300' }
                    ],
                    flop: [
                        { player: 'C', action: 'Checks', amount: null },
                        { player: 'D', action: 'Bets', amount: '600' },
                        { player: 'A', action: 'Folds', amount: null },
                        { player: 'B', action: 'Folds', amount: null },
                        { player: 'C', action: 'Calls', amount: '600' }
                    ],
                    turn: [],
                    river: []
                },
                players: [
                    { name: 'A' },
                    { name: 'B' },
                    { name: 'C' },
                    { name: 'D' }
                ],
                playerStatus: {
                    'A': 'folded',
                    'B': 'folded',
                    'C': 'active',
                    'D': 'active'
                },
                expected: 2450  // SB(50) + BB(100) + 4*300 + 2*600
            },
            test3: {
                actionState: {
                    smallBlind: '0',
                    bigBlind: '0',
                    preflop: [],
                    flop: [
                        { action: 'Pot Correction', amount: '1000' },
                        { player: 'A', action: 'Bets', amount: '500' },
                        { player: 'B', action: 'All In', amount: '3000' },
                        { player: 'A', action: 'Folds', amount: null }
                    ],
                    turn: [],
                    river: []
                },
                players: [
                    { name: 'A' },
                    { name: 'B' }
                ],
                playerStatus: {
                    'A': 'folded',
                    'B': 'active'
                },
                expected: 1500  // 1000 + 500 (ì–¸ì½œ 2500 ì œì™¸)
            },
            test4: {
                actionState: {
                    smallBlind: '50',
                    bigBlind: '100',
                    preflop: [
                        { player: 'A', action: 'Raises', amount: '300' },
                        { player: 'B', action: 'Calls', amount: '300' }
                    ],
                    flop: [
                        { action: 'Pot Correction', amount: '1000' },
                        { player: 'A', action: 'Bets', amount: '200' },
                        { player: 'B', action: 'Calls', amount: '200' }
                    ],
                    turn: [],
                    river: []
                },
                players: [
                    { name: 'A' },
                    { name: 'B' }
                ],
                playerStatus: {
                    'A': 'active',
                    'B': 'active'
                },
                expected: 1400  // Correction 1000 + 400
            }
        };
        
        function runTest(testId) {
            const test = testCases[testId];
            const state = createTestState(test);
            const result = calculateActualPot(state);
            
            const resultElement = document.getElementById(`result${testId.slice(-1)}`);
            if(result === test.expected) {
                resultElement.innerHTML = `<span class="success">${formatNumber(result)} âœ… ì •ë‹µ!</span>`;
            } else {
                resultElement.innerHTML = `<span class="error">${formatNumber(result)} âŒ (ì˜ˆìƒ: ${formatNumber(test.expected)})</span>`;
            }
            
            // ì–¸ì½œ ë² íŒ…ì´ ìˆëŠ” ê²½ìš° í‘œì‹œ
            if(testId === 'test3') {
                const uncalled = calculateUncalledBet(state);
                resultElement.innerHTML += `<br>ì–¸ì½œ ë² íŒ…: ${formatNumber(uncalled.amount)}`;
            }
        }
        
        function runAllTests() {
            Object.keys(testCases).forEach(testId => {
                runTest(testId);
            });
        }
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ ì‹¤í–‰
        window.onload = runAllTests;
    </script>
</body>
</html>