/**
 * Incremental Update Manager - ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï∏° Ï¶ùÎ∂Ñ ÏóÖÎç∞Ïù¥Ìä∏ Í¥ÄÎ¶¨
 * Day 3 Íµ¨ÌòÑ
 */

class IncrementalUpdateManager {
    constructor(appsScriptUrl) {
        this.appsScriptUrl = appsScriptUrl;
        this.clientId = this.generateClientId();
        this.currentVersion = null;
        this.dataStore = [];
        this.updateQueue = [];
        this.isProcessing = false;
        this.conflictStrategy = 'server-wins';

        // ÌÜµÍ≥Ñ
        this.stats = {
            fullSyncs: 0,
            incrementalUpdates: 0,
            conflictsResolved: 0,
            deltasApplied: 0,
            startTime: Date.now()
        };

        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        this.eventListeners = {
            deltaReceived: [],
            deltaApplied: [],
            conflictDetected: [],
            fullSyncRequired: [],
            error: []
        };

        console.log(`üîß IncrementalUpdateManager Ï¥àÍ∏∞Ìôî (ID: ${this.clientId})`);
    }

    /**
     * Í≥†Ïú† ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ID ÏÉùÏÑ±
     */
    generateClientId() {
        return `client_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ù
     */
    on(event, callback) {
        if (this.eventListeners[event]) {
            this.eventListeners[event].push(callback);
        }
    }

    /**
     * Ïù¥Î≤§Ìä∏ Î∞úÏÉù
     */
    emit(event, data) {
        if (this.eventListeners[event]) {
            this.eventListeners[event].forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`Event listener error (${event}):`, error);
                }
            });
        }
    }

    /**
     * Ï¶ùÎ∂Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏöîÏ≤≠
     */
    async fetchUpdate() {
        const startTime = performance.now();

        try {
            const url = `${this.appsScriptUrl}?action=getIncremental&clientId=${encodeURIComponent(this.clientId)}&version=${encodeURIComponent(this.currentVersion || '')}`;

            const response = await fetch(url, {
                method: 'GET',
                mode: 'cors',
                cache: 'no-cache'
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const update = await response.json();
            const endTime = performance.now();

            // ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ
            if (window.performanceMonitor) {
                window.performanceMonitor.trackApiCall(
                    'incremental',
                    endTime - startTime,
                    JSON.stringify(update).length
                );
            }

            console.log(`üì¶ ÏóÖÎç∞Ïù¥Ìä∏ ÏàòÏã†: ÌÉÄÏûÖ=${update.type}, ÏãúÍ∞Ñ=${(endTime - startTime).toFixed(0)}ms`);

            // ÏóÖÎç∞Ïù¥Ìä∏ Ï†ÅÏö©
            await this.applyUpdate(update);

            return update;

        } catch (error) {
            console.error('‚ùå Ï¶ùÎ∂Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:', error);
            this.emit('error', error);
            throw error;
        }
    }

    /**
     * ÏóÖÎç∞Ïù¥Ìä∏ Ï†ÅÏö©
     */
    async applyUpdate(update) {
        if (update.type === 'full') {
            // Ï†ÑÏ≤¥ ÎèôÍ∏∞Ìôî
            console.log('üîÑ Ï†ÑÏ≤¥ ÎèôÍ∏∞Ìôî ÏàòÌñâ');
            this.dataStore = update.data;
            this.currentVersion = update.version;
            this.stats.fullSyncs++;

            this.emit('fullSyncRequired', {
                data: update.data,
                version: update.version,
                reason: 'Version mismatch or first sync'
            });

        } else if (update.type === 'incremental') {
            // Ï¶ùÎ∂Ñ ÏóÖÎç∞Ïù¥Ìä∏
            console.log(`üî∫ Ï¶ùÎ∂Ñ ÏóÖÎç∞Ïù¥Ìä∏: +${update.stats.added} ~${update.stats.modified} -${update.stats.deleted}`);

            this.emit('deltaReceived', {
                delta: update.delta,
                stats: update.stats
            });

            await this.applyDelta(update.delta);
            this.currentVersion = update.version;
            this.stats.incrementalUpdates++;
        }
    }

    /**
     * Îç∏ÌÉÄ Ï†ÅÏö©
     */
    async applyDelta(delta) {
        // ÏóÖÎç∞Ïù¥Ìä∏ ÌÅêÏóê Ï∂îÍ∞Ä
        this.updateQueue.push(delta);

        if (!this.isProcessing) {
            await this.processUpdateQueue();
        }
    }

    /**
     * ÏóÖÎç∞Ïù¥Ìä∏ ÌÅê Ï≤òÎ¶¨
     */
    async processUpdateQueue() {
        this.isProcessing = true;

        while (this.updateQueue.length > 0) {
            const delta = this.updateQueue.shift();
            const startTime = performance.now();

            try {
                // ÏÇ≠Ï†ú Ï≤òÎ¶¨ (Ïó≠Ïàú)
                if (delta.deleted && delta.deleted.length > 0) {
                    delta.deleted
                        .sort((a, b) => b.row - a.row)
                        .forEach(deletion => {
                            this.dataStore.splice(deletion.row, 1);
                            this.updateRowInDOM('delete', deletion.row);
                        });
                }

                // ÏàòÏ†ï Ï≤òÎ¶¨
                if (delta.modified && delta.modified.length > 0) {
                    delta.modified.forEach(modification => {
                        if (this.dataStore[modification.row]) {
                            modification.cells.forEach(cell => {
                                this.dataStore[modification.row][cell.col] = cell.newValue;
                            });
                            this.updateRowInDOM('modify', modification.row, this.dataStore[modification.row]);
                        }
                    });
                }

                // Ï∂îÍ∞Ä Ï≤òÎ¶¨
                if (delta.added && delta.added.length > 0) {
                    delta.added.forEach(addition => {
                        // ÏßÄÏ†ïÎêú ÏúÑÏπòÏóê ÏÇΩÏûÖ ÎòêÎäî ÎÅùÏóê Ï∂îÍ∞Ä
                        if (addition.row >= this.dataStore.length) {
                            this.dataStore.push(addition.data);
                        } else {
                            this.dataStore.splice(addition.row, 0, addition.data);
                        }
                        this.updateRowInDOM('add', addition.row, addition.data);
                    });
                }

                const elapsed = performance.now() - startTime;
                this.stats.deltasApplied++;

                console.log(`‚úÖ Îç∏ÌÉÄ Ï†ÅÏö© ÏôÑÎ£å (${elapsed.toFixed(0)}ms)`);

                this.emit('deltaApplied', {
                    delta: delta,
                    dataStore: this.dataStore,
                    elapsed: elapsed
                });

            } catch (error) {
                console.error('‚ùå Îç∏ÌÉÄ Ï†ÅÏö© Ïò§Î•ò:', error);
                this.emit('error', error);
            }
        }

        this.isProcessing = false;
    }

    /**
     * DOM ÏóÖÎç∞Ïù¥Ìä∏ (ÏµúÏ†ÅÌôî)
     */
    updateRowInDOM(action, rowIndex, rowData = null) {
        // RequestAnimationFrameÏúºÎ°ú Î∞∞Ïπò Ï≤òÎ¶¨
        requestAnimationFrame(() => {
            const tbody = document.querySelector('#data-tbody');
            if (!tbody) return;

            switch (action) {
                case 'delete':
                    const rowToDelete = tbody.rows[rowIndex];
                    if (rowToDelete) {
                        rowToDelete.classList.add('row-deleted');
                        setTimeout(() => rowToDelete.remove(), 300);
                    }
                    break;

                case 'modify':
                    const rowToModify = tbody.rows[rowIndex];
                    if (rowToModify && rowData) {
                        // ÏÖÄ ÏóÖÎç∞Ïù¥Ìä∏
                        rowData.forEach((value, colIndex) => {
                            if (rowToModify.cells[colIndex + 1]) { // +1 for row number column
                                const cell = rowToModify.cells[colIndex + 1];
                                if (cell.textContent !== value) {
                                    cell.textContent = value;
                                    cell.classList.add('cell-updated');
                                    setTimeout(() => cell.classList.remove('cell-updated'), 500);
                                }
                            }
                        });
                    }
                    break;

                case 'add':
                    const newRow = tbody.insertRow(rowIndex);
                    newRow.innerHTML = `
                        <td class="p-2">${rowIndex + 1}</td>
                        ${rowData.map(value => `<td class="p-2">${value || '-'}</td>`).join('')}
                    `;
                    newRow.classList.add('row-added');
                    setTimeout(() => newRow.classList.remove('row-added'), 500);
                    break;
            }
        });
    }

    /**
     * Î°úÏª¨ Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï∂îÏ†Å
     */
    trackLocalChange(row, col, newValue) {
        const change = {
            row: row,
            col: col,
            oldValue: this.dataStore[row] ? this.dataStore[row][col] : null,
            newValue: newValue,
            timestamp: Date.now()
        };

        // Î°úÏª¨ Îç∞Ïù¥ÌÑ∞Ïä§ÌÜ†Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏
        if (this.dataStore[row]) {
            this.dataStore[row][col] = newValue;
        }

        return change;
    }

    /**
     * Ï∂©Îèå Ìï¥Í≤∞
     */
    async resolveConflicts(localChanges, serverDelta) {
        const conflicts = this.detectConflicts(localChanges, serverDelta);

        if (conflicts.length > 0) {
            console.warn(`‚ö†Ô∏è ${conflicts.length}Í∞ú Ï∂©Îèå Í∞êÏßÄ`);

            this.emit('conflictDetected', {
                conflicts: conflicts,
                strategy: this.conflictStrategy
            });

            const resolutions = this.applyConflictStrategy(conflicts);
            this.stats.conflictsResolved += conflicts.length;

            return resolutions;
        }

        return [];
    }

    /**
     * Ï∂©Îèå Í∞êÏßÄ
     */
    detectConflicts(localChanges, serverDelta) {
        const conflicts = [];

        localChanges.forEach(localChange => {
            serverDelta.modified?.forEach(serverMod => {
                if (localChange.row === serverMod.row) {
                    serverMod.cells.forEach(serverCell => {
                        if (localChange.col === serverCell.col) {
                            conflicts.push({
                                row: localChange.row,
                                col: localChange.col,
                                localValue: localChange.newValue,
                                serverValue: serverCell.newValue,
                                baseValue: serverCell.oldValue
                            });
                        }
                    });
                }
            });
        });

        return conflicts;
    }

    /**
     * Ï∂©Îèå Ìï¥Í≤∞ Ï†ÑÎûµ Ï†ÅÏö©
     */
    applyConflictStrategy(conflicts) {
        const resolutions = [];

        conflicts.forEach(conflict => {
            let resolution;

            switch (this.conflictStrategy) {
                case 'server-wins':
                    resolution = conflict.serverValue;
                    break;

                case 'client-wins':
                    resolution = conflict.localValue;
                    break;

                case 'merge':
                    if (typeof conflict.localValue === 'number' && typeof conflict.serverValue === 'number') {
                        resolution = (conflict.localValue + conflict.serverValue) / 2;
                    } else {
                        resolution = `${conflict.localValue} | ${conflict.serverValue}`;
                    }
                    break;

                default:
                    resolution = conflict.serverValue;
            }

            resolutions.push({
                row: conflict.row,
                col: conflict.col,
                value: resolution,
                strategy: this.conflictStrategy
            });

            // Ìï¥Í≤∞Îêú Í∞í Ï†ÅÏö©
            if (this.dataStore[conflict.row]) {
                this.dataStore[conflict.row][conflict.col] = resolution;
            }
        });

        return resolutions;
    }

    /**
     * Ï†ÑÏ≤¥ ÎèôÍ∏∞Ìôî Í∞ïÏ†ú Ïã§Ìñâ
     */
    async forceFullSync() {
        console.log('üîÑ Í∞ïÏ†ú Ï†ÑÏ≤¥ ÎèôÍ∏∞Ìôî');
        this.currentVersion = null;
        return await this.fetchUpdate();
    }

    /**
     * Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
     */
    getData() {
        return this.dataStore;
    }

    /**
     * ÌÜµÍ≥Ñ Ï°∞Ìöå
     */
    getStats() {
        const elapsed = (Date.now() - this.stats.startTime) / 1000;

        return {
            clientId: this.clientId,
            currentVersion: this.currentVersion ? this.currentVersion.substring(0, 8) + '...' : null,
            dataRows: this.dataStore.length,
            fullSyncs: this.stats.fullSyncs,
            incrementalUpdates: this.stats.incrementalUpdates,
            deltasApplied: this.stats.deltasApplied,
            conflictsResolved: this.stats.conflictsResolved,
            runningTime: elapsed.toFixed(0) + 's',
            efficiency: this.stats.incrementalUpdates > 0
                ? ((this.stats.incrementalUpdates / (this.stats.fullSyncs + this.stats.incrementalUpdates)) * 100).toFixed(1) + '%'
                : '0%'
        };
    }

    /**
     * ÏÉÅÌÉú Ï°∞Ìöå
     */
    getStatus() {
        return {
            clientId: this.clientId,
            hasData: this.dataStore.length > 0,
            currentVersion: this.currentVersion,
            queueLength: this.updateQueue.length,
            isProcessing: this.isProcessing,
            conflictStrategy: this.conflictStrategy,
            stats: this.getStats()
        };
    }

    /**
     * Ï∂©Îèå Ï†ÑÎûµ ÏÑ§Ï†ï
     */
    setConflictStrategy(strategy) {
        const validStrategies = ['server-wins', 'client-wins', 'merge'];
        if (validStrategies.includes(strategy)) {
            this.conflictStrategy = strategy;
            console.log(`‚úÖ Ï∂©Îèå Ìï¥Í≤∞ Ï†ÑÎûµ Î≥ÄÍ≤Ω: ${strategy}`);
        } else {
            console.warn(`‚ö†Ô∏è Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ï†ÑÎûµ: ${strategy}`);
        }
    }
}

// Ï†ÑÏó≠ Ìó¨Ìçº Ìï®Ïàò
function initializeIncrementalManager(appsScriptUrl) {
    const manager = new IncrementalUpdateManager(appsScriptUrl);

    // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
    manager.on('deltaReceived', (data) => {
        console.log(`üì• Îç∏ÌÉÄ ÏàòÏã†: +${data.stats.added} ~${data.stats.modified} -${data.stats.deleted}`);
    });

    manager.on('deltaApplied', (data) => {
        console.log(`‚úÖ Îç∏ÌÉÄ Ï†ÅÏö© ÏôÑÎ£å (${data.elapsed.toFixed(0)}ms)`);
    });

    manager.on('conflictDetected', (data) => {
        console.warn(`‚ö†Ô∏è Ï∂©Îèå Í∞êÏßÄ: ${data.conflicts.length}Í∞ú (Ï†ÑÎûµ: ${data.strategy})`);
    });

    manager.on('fullSyncRequired', (data) => {
        console.log(`üîÑ Ï†ÑÏ≤¥ ÎèôÍ∏∞Ìôî: ${data.reason}`);
    });

    manager.on('error', (error) => {
        console.error('‚ùå IncrementalManager Ïò§Î•ò:', error);
    });

    // Ï†ÑÏó≠ Îì±Î°ù
    window.incrementalManager = manager;

    console.log('‚úÖ IncrementalUpdateManager Ï†ÑÏó≠ Îì±Î°ù ÏôÑÎ£å');
    return manager;
}

// Î™®Îìà ÎÇ¥Î≥¥ÎÇ¥Í∏∞
if (typeof module !== 'undefined' && module.exports) {
    module.exports = IncrementalUpdateManager;
}