<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Google Sheets CSV 연동 테스트 도구 v1.1 (Fixed)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 100%);
            color: #f8fafc;
            min-height: 100vh;
        }
        
        .mono {
            font-family: 'JetBrains Mono', monospace;
        }
        
        .test-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .status-pending { background: #fbbf24; color: #92400e; }
        .status-running { background: #3b82f6; color: #1e40af; }
        .status-success { background: #10b981; color: #065f46; }
        .status-error { background: #ef4444; color: #991b1b; }
        
        .log-output {
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 12px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .url-input {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 8px;
            padding: 12px;
            transition: all 0.2s;
            width: 100%;
        }
        
        .url-input:focus {
            outline: none;
            border-color: #3b82f6;
            background: rgba(255, 255, 255, 0.15);
        }
        
        .url-valid { border-color: #10b981 !important; }
        .url-warning { border-color: #f59e0b !important; }
        .url-error { border-color: #ef4444 !important; }
        
        .btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s;
            cursor: pointer;
            border: none;
            margin: 4px;
        }
        
        .btn-primary {
            background: #3b82f6;
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background: #2563eb;
        }
        
        .btn-success {
            background: #10b981;
            color: white;
        }
        
        .btn-secondary {
            background: #6b7280;
            color: white;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #10b981);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold mb-4">🧪 Google Sheets CSV 연동 테스트 도구</h1>
            <p class="text-xl text-blue-200">Virtual 시트 매칭 시스템 디버깅 및 테스트 (Fixed v1.1)</p>
        </div>

        <!-- 단계별 테스트 진행도 -->
        <div class="test-card">
            <h2 class="text-2xl font-bold mb-4">📊 테스트 진행도</h2>
            <div class="progress-bar mb-4">
                <div id="progress-fill" class="progress-fill"></div>
            </div>
            <div class="grid grid-cols-2 md:grid-cols-5 gap-4">
                <div class="text-center">
                    <div id="step1-status" class="status-badge status-pending mb-2">대기</div>
                    <div class="text-sm">URL 검증</div>
                </div>
                <div class="text-center">
                    <div id="step2-status" class="status-badge status-pending mb-2">대기</div>
                    <div class="text-sm">CSV 접근</div>
                </div>
                <div class="text-center">
                    <div id="step3-status" class="status-badge status-pending mb-2">대기</div>
                    <div class="text-sm">데이터 파싱</div>
                </div>
                <div class="text-center">
                    <div id="step4-status" class="status-badge status-pending mb-2">대기</div>
                    <div class="text-sm">시간 매칭</div>
                </div>
                <div class="text-center">
                    <div id="step5-status" class="status-badge status-pending mb-2">대기</div>
                    <div class="text-sm">결과 검증</div>
                </div>
            </div>
        </div>

        <!-- 입력 섹션 -->
        <div class="test-card">
            <h2 class="text-2xl font-bold mb-4">🔗 테스트 설정</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <label class="block text-sm font-medium mb-2">Google Sheets URL</label>
                    <input 
                        type="text" 
                        id="sheets-url" 
                        class="url-input"
                        placeholder="https://docs.google.com/spreadsheets/d/..."
                    >
                    <div id="url-feedback" class="mt-2 text-sm"></div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">테스트할 시간 (Seoul 기준)</label>
                    <input 
                        type="text" 
                        id="target-time" 
                        class="url-input"
                        placeholder="14:30:25 또는 14시 30분 25초"
                        value="14:30:25"
                    >
                </div>
            </div>
            <div class="mt-6 flex gap-4 flex-wrap">
                <button id="start-test" class="btn btn-primary">🚀 자동 테스트</button>
                <button id="manual-csv-test" class="btn btn-success">📋 수동 CSV 테스트</button>
                <button id="clear-logs" class="btn btn-secondary">🗑️ 로그 지우기</button>
            </div>
        </div>

        <!-- 실시간 로그 -->
        <div class="test-card">
            <h2 class="text-2xl font-bold mb-4">📝 실시간 로그</h2>
            <div id="log-output" class="log-output">
                <div class="text-gray-400">테스트를 시작하려면 위의 버튼을 클릭하세요.</div>
            </div>
        </div>

        <!-- 결과 섹션 -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <!-- CSV 데이터 미리보기 -->
            <div class="test-card">
                <h2 class="text-2xl font-bold mb-4">📄 CSV 데이터 미리보기</h2>
                <div id="csv-preview" class="log-output">
                    <div class="text-gray-400">CSV 데이터를 불러오면 여기에 표시됩니다.</div>
                </div>
            </div>

            <!-- 매칭 결과 -->
            <div class="test-card">
                <h2 class="text-2xl font-bold mb-4">🎯 매칭 결과</h2>
                <div id="match-result" class="log-output">
                    <div class="text-gray-400">매칭 결과가 여기에 표시됩니다.</div>
                </div>
            </div>
        </div>

        <!-- 문제 진단 섹션 -->
        <div class="test-card">
            <h2 class="text-2xl font-bold mb-4">🔍 문제 진단</h2>
            <div id="diagnosis-result" class="log-output">
                <div class="text-gray-400">테스트 완료 후 문제 진단 결과가 표시됩니다.</div>
            </div>
        </div>
    </div>

    <script>
        // 전역 변수
        let testResults = {};
        let currentStep = 0;
        const totalSteps = 5;

        // 로그 출력 함수
        function log(message, type = 'info') {
            const logOutput = document.getElementById('log-output');
            const timestamp = new Date().toLocaleTimeString();
            const colors = {
                info: '#94a3b8',
                success: '#10b981',
                warning: '#f59e0b',
                error: '#ef4444',
                debug: '#8b5cf6'
            };
            
            const logEntry = document.createElement('div');
            logEntry.style.color = colors[type] || colors.info;
            logEntry.innerHTML = `<span style="color: #64748b">[${timestamp}]</span> ${message}`;
            
            logOutput.appendChild(logEntry);
            logOutput.scrollTop = logOutput.scrollHeight;
        }

        // 진행도 업데이트
        function updateProgress(step) {
            currentStep = step;
            const progressFill = document.getElementById('progress-fill');
            const percentage = (step / totalSteps) * 100;
            progressFill.style.width = `${percentage}%`;
        }

        // 단계 상태 업데이트
        function updateStepStatus(step, status) {
            const stepElement = document.getElementById(`step${step}-status`);
            stepElement.className = `status-badge status-${status}`;
            stepElement.textContent = {
                pending: '대기',
                running: '진행중',
                success: '성공',
                error: '실패'
            }[status];
        }

        // Google Sheets URL 검증 함수
        function validateGoogleSheetsUrl(url) {
            if (!url || !url.trim()) {
                return {
                    valid: false,
                    type: 'empty',
                    message: 'URL이 입력되지 않았습니다',
                    color: '#ef4444'
                };
            }
            
            const trimmedUrl = url.trim();
            
            // 1. 이미 웹 게시된 CSV URL (가장 권장)
            if (trimmedUrl.includes('/pub?') && trimmedUrl.includes('output=csv')) {
                return {
                    valid: true,
                    type: 'published-csv',
                    message: '✅ 완벽한 웹 게시 CSV URL (권장)',
                    color: '#10b981',
                    csvUrl: trimmedUrl
                };
            }
            
            // 2. 웹 게시된 일반 URL (2PACX 형식)
            if (trimmedUrl.includes('/spreadsheets/d/e/2PACX-')) {
                const gidMatch = trimmedUrl.match(/gid=(\d+)/);
                const gid = gidMatch ? gidMatch[1] : '0';
                const publishedIdMatch = trimmedUrl.match(/\/spreadsheets\/d\/e\/(2PACX-[a-zA-Z0-9-_]+)/);
                
                if (publishedIdMatch) {
                    const csvUrl = `https://docs.google.com/spreadsheets/d/e/${publishedIdMatch[1]}/pub?gid=${gid}&single=true&output=csv`;
                    return {
                        valid: true,
                        type: 'published-converted',
                        message: '🟡 웹 게시 URL (자동으로 CSV로 변환됨)',
                        color: '#f59e0b',
                        csvUrl: csvUrl
                    };
                }
            }
            
            // 3. 일반 편집 URL (비추천)
            if (trimmedUrl.includes('/spreadsheets/d/') && !trimmedUrl.includes('/pub?')) {
                const sheetIdMatch = trimmedUrl.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
                
                if (sheetIdMatch) {
                    const sheetId = sheetIdMatch[1];
                    const gidMatch = trimmedUrl.match(/gid=(\d+)/);
                    const gid = gidMatch ? gidMatch[1] : '0';
                    const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=${gid}`;
                    
                    return {
                        valid: true,
                        type: 'export-url',
                        message: '🟠 편집 URL (CORS 및 권한 문제 가능성)',
                        color: '#f59e0b',
                        csvUrl: csvUrl,
                        warning: true
                    };
                }
            }
            
            // 4. 지원되지 않는 형식
            if (trimmedUrl.includes('docs.google.com')) {
                return {
                    valid: false,
                    type: 'unsupported',
                    message: '🔴 지원되지 않는 Google Sheets URL 형식',
                    color: '#ef4444'
                };
            }
            
            return {
                valid: false,
                type: 'invalid',
                message: '❌ Google Sheets URL이 아닙니다',
                color: '#ef4444'
            };
        }

        // CSV 파싱 함수
        function parseCSV(text) {
            const rows = [];
            const lines = text.split(/\r?\n/);
            
            for (let line of lines) {
                if (!line.trim()) continue;
                
                const row = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"' && (i === 0 || line[i-1] !== '\\')) {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        row.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                row.push(current.trim());
                rows.push(row);
            }
            
            return rows;
        }

        // 시간 파싱 함수
        function parseTimeString(timeStr) {
            const timePatterns = [
                { pattern: /(\d{1,2}):(\d{2}):(\d{2})/, name: 'HH:MM:SS' },
                { pattern: /(\d{1,2}):(\d{2})/, name: 'HH:MM' },
                { pattern: /(\d{1,2})시\s*(\d{1,2})분\s*(\d{1,2})초/, name: '한국어 시:분:초' },
                { pattern: /(\d{1,2})시\s*(\d{1,2})분/, name: '한국어 시:분' }
            ];
            
            for (const {pattern, name} of timePatterns) {
                const match = timeStr.match(pattern);
                if (match) {
                    const hours = parseInt(match[1]);
                    const minutes = parseInt(match[2]);
                    const seconds = match[3] ? parseInt(match[3]) : 0;
                    
                    return {
                        hours,
                        minutes,
                        seconds,
                        totalSeconds: hours * 3600 + minutes * 60 + seconds,
                        pattern: name,
                        formatted: `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
                    };
                }
            }
            
            return null;
        }

        // CSV 파싱 함수 (GitHub 저장소에서 가져온 검증된 방법)
        function parseCSV(text) {
            const rows = [];
            const lines = text.split(/\r?\n/);
            
            for (let line of lines) {
                if (!line.trim()) continue;
                
                const row = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"' && (i === 0 || line[i-1] !== '\\')) {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        row.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                row.push(current.trim());
                rows.push(row);
            }
            
            return rows;
        }

        // GitHub 저장소 방식의 CSV fetch 함수 (올바른 구현)
        async function fetchCsv(url) {
            log(`🔄 GitHub 방식: 직접 CSV fetch 시도`, 'debug');
            log(`📡 요청 URL: ${url}`, 'debug');
            
            try {
                // GitHub 저장소와 동일한 단순한 fetch
                const res = await fetch(url);
                
                log(`📊 HTTP 응답: ${res.status} ${res.statusText}`, res.ok ? 'success' : 'error');
                log(`📊 Content-Type: ${res.headers.get('content-type')}`, 'debug');
                
                if (!res.ok) {
                    throw new Error(`CSV fetch failed: ${res.status}`);
                }
                
                const txt = await res.text();
                log(`✅ 직접 방법 성공: ${txt.length}글자`, 'success');
                
                const rows = parseCSV(txt);
                log(`✅ CSV 파싱 성공: ${rows.length}행`, 'success');
                
                return { 
                    response: {
                        ok: true,
                        status: res.status,
                        statusText: res.statusText,
                        headers: { get: (key) => res.headers.get(key) },
                        text: async () => txt
                    },
                    fetchMethod: '직접 fetch (GitHub 방식)',
                    csvText: txt,
                    parsedRows: rows
                };
                
            } catch (error) {
                log(`❌ 직접 방법 실패: ${error.message}`, 'error');
                log('💡 CORS 문제일 가능성이 높습니다. 프록시 방법을 시도합니다.', 'debug');
                
                // 프록시 방법 시도
                try {
                    log('🔄 방법 2: AllOrigins 프록시 시도', 'debug');
                    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                    const proxyResponse = await fetch(proxyUrl);
                    const proxyData = await proxyResponse.json();
                    
                    if (!proxyData.contents) {
                        throw new Error('프록시에서 빈 데이터 반환');
                    }
                    
                    let csvText = proxyData.contents;
                    
                    // Base64로 인코딩된 데이터인지 확인 및 디코딩
                    if (csvText.startsWith('data:text/csv;base64,')) {
                        log('🔄 Base64 인코딩 데이터 감지 - 디코딩 중...', 'debug');
                        const base64Data = csvText.replace('data:text/csv;base64,', '');
                        try {
                            csvText = atob(base64Data);
                            log(`✅ Base64 디코딩 성공: ${csvText.length}글자`, 'success');
                        } catch (decodeError) {
                            log(`❌ Base64 디코딩 실패: ${decodeError.message}`, 'error');
                            throw new Error(`Base64 디코딩 실패: ${decodeError.message}`);
                        }
                    }
                    
                    const rows = parseCSV(csvText);
                    log(`✅ 프록시 방법 성공: ${rows.length}행`, 'success');
                    
                    return {
                        response: {
                            ok: true,
                            status: 200,
                            statusText: 'OK (Proxy)',
                            headers: { get: (key) => key === 'content-type' ? 'text/csv' : null },
                            text: async () => csvText
                        },
                        fetchMethod: 'AllOrigins 프록시',
                        csvText: csvText,
                        parsedRows: rows
                    };
                    
                } catch (error2) {
                    log(`❌ 프록시 방법 실패: ${error2.message}`, 'error');
                    throw new Error(`모든 fetch 방법 실패. 직접: ${error.message}, 프록시: ${error2.message}`);
                }
            }
        }

        // 메인 테스트 함수
        async function runTest() {
            const url = document.getElementById('sheets-url').value;
            const targetTimeStr = document.getElementById('target-time').value;
            
            testResults = {};
            log('🚀 === Google Sheets CSV 연동 테스트 시작 ===', 'info');
            
            // 초기화
            updateProgress(0);
            for (let i = 1; i <= totalSteps; i++) {
                updateStepStatus(i, 'pending');
            }
            
            try {
                // 1단계: URL 검증
                updateStepStatus(1, 'running');
                updateProgress(1);
                log('📋 1단계: URL 검증 시작', 'info');
                
                const urlValidation = validateGoogleSheetsUrl(url);
                testResults.urlValidation = urlValidation;
                
                log(`🔗 입력 URL: ${url}`, 'debug');
                log(`💬 검증 결과: ${urlValidation.message}`, urlValidation.valid ? 'success' : 'error');
                
                if (!urlValidation.valid) {
                    updateStepStatus(1, 'error');
                    throw new Error(`URL 검증 실패: ${urlValidation.message}`);
                }
                
                updateStepStatus(1, 'success');
                log(`✅ CSV URL: ${urlValidation.csvUrl}`, 'success');
                
                // 2단계: CSV 데이터 접근
                updateStepStatus(2, 'running');
                updateProgress(2);
                log('📥 2단계: CSV 데이터 접근 시작', 'info');
                
                const { response, fetchMethod, csvText, parsedRows } = await fetchCsv(urlValidation.csvUrl);
                log(`📊 사용된 방법: ${fetchMethod}`, 'info');
                
                testResults.httpResponse = {
                    status: response.status,
                    statusText: response.statusText,
                    contentType: response.headers.get('content-type'),
                    ok: response.ok
                };
                
                log(`📊 HTTP 응답: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
                
                if (!response.ok) {
                    updateStepStatus(2, 'error');
                    throw new Error(`HTTP 오류: ${response.status} ${response.statusText}`);
                }
                
                testResults.csvText = csvText;
                testResults.parsedRows = parsedRows;
                
                log(`📄 CSV 데이터 크기: ${csvText.length} 글자`, 'success');
                updateStepStatus(2, 'success');
                
                // CSV 미리보기 업데이트
                document.getElementById('csv-preview').innerHTML = `
                    <div style="color: #10b981;">✅ 데이터 크기: ${csvText.length} 글자</div>
                    <div style="color: #64748b; margin-top: 8px;">첫 500자:</div>
                    <pre style="white-space: pre-wrap; margin-top: 4px; color: #e2e8f0;">${csvText.substring(0, 500)}${csvText.length > 500 ? '...' : ''}</pre>
                `;
                
                // 3단계: 데이터 파싱 (이미 완료)
                updateStepStatus(3, 'running');
                updateProgress(3);
                log('🔧 3단계: CSV 데이터 파싱 (이미 GitHub 방법에서 완료)', 'info');
                
                const rows = parsedRows;
                
                log(`📋 파싱된 행 수: ${rows.length}`, 'success');
                
                if (rows.length === 0) {
                    updateStepStatus(3, 'error');
                    throw new Error('CSV에 데이터가 없습니다');
                }
                
                // 첫 5행 로그
                log('📊 CSV 데이터 구조 (첫 5행):', 'debug');
                for (let i = 0; i < Math.min(5, rows.length); i++) {
                    log(`   행 ${i+1}: A="${rows[i][0] || ''}", B="${rows[i][1] || ''}", C="${rows[i][2] || ''}", D="${rows[i][3] || ''}"`, 'debug');
                }
                
                updateStepStatus(3, 'success');
                
                // 4단계: 시간 매칭
                updateStepStatus(4, 'running');
                updateProgress(4);
                log('⏰ 4단계: 시간 매칭 시작', 'info');
                
                const targetTime = parseTimeString(targetTimeStr);
                if (!targetTime) {
                    updateStepStatus(4, 'error');
                    throw new Error(`타겟 시간 파싱 실패: ${targetTimeStr}`);
                }
                
                log(`🎯 타겟 시간: ${targetTime.formatted} (${targetTime.totalSeconds}초)`, 'info');
                
                let closestRow = null;
                let minDiff = Infinity;
                let rowIndex = -1;
                let matchedTime = null;
                let validTimeCount = 0;
                
                for (let i = 0; i < rows.length; i++) {
                    const cellValue = rows[i][2]; // C열
                    if (!cellValue || !cellValue.trim()) continue;
                    
                    const cellTime = parseTimeString(cellValue);
                    if (!cellTime) {
                        log(`   행 ${i+1} C열: "${cellValue}" - 매칭 실패`, 'debug');
                        continue;
                    }
                    
                    validTimeCount++;
                    const diff = Math.abs(cellTime.totalSeconds - targetTime.totalSeconds);
                    
                    log(`   행 ${i+1} C열: "${cellValue}" → ${cellTime.formatted} (차이: ${diff}초)`, 'debug');
                    
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestRow = rows[i];
                        rowIndex = i + 1;
                        matchedTime = cellTime;
                        
                        log(`   🎯 새로운 최적 매칭: 행 ${rowIndex}, 차이 ${diff}초`, 'success');
                        
                        if (diff <= 5) {
                            log('✅ 정확한 매칭 발견! (5초 이내)', 'success');
                            break;
                        }
                    }
                }
                
                testResults.matching = {
                    targetTime,
                    validTimeCount,
                    closestRow,
                    rowIndex,
                    matchedTime,
                    minDiff,
                    success: closestRow !== null
                };
                
                log(`📊 매칭 요약: 유효한 시간 ${validTimeCount}개, 최소 차이 ${minDiff === Infinity ? '무한' : minDiff + '초'}`, 'info');
                
                if (closestRow) {
                    updateStepStatus(4, 'success');
                    
                    const accuracy = minDiff <= 5 ? '정확 (5초 이내)' : minDiff <= 30 ? '근사 (30초 이내)' : '대략적 (30초 초과)';
                    log(`✅ 매칭 성공: 행 ${rowIndex}, 시간 ${matchedTime.formatted}, 정확도 ${accuracy}`, 'success');
                    
                    document.getElementById('match-result').innerHTML = `
                        <div style="color: #10b981;">✅ 매칭 성공!</div>
                        <div style="margin-top: 8px;">
                            <div>📍 위치: 행 ${rowIndex}</div>
                            <div>🎯 타겟 시간: ${targetTime.formatted}</div>
                            <div>🕐 매칭된 시간: ${matchedTime.formatted}</div>
                            <div>⏰ 시간 차이: ${minDiff}초</div>
                            <div>📊 정확도: ${accuracy}</div>
                            <div style="margin-top: 8px; color: #64748b;">전체 행 데이터:</div>
                            <div>A열: "${closestRow[0] || ''}"</div>
                            <div>B열: "${closestRow[1] || ''}"</div>
                            <div>C열: "${closestRow[2] || ''}"</div>
                            <div>D열: "${closestRow[3] || ''}"</div>
                        </div>
                    `;
                } else {
                    updateStepStatus(4, 'error');
                    log('❌ 매칭할 수 있는 시간 데이터를 찾지 못했습니다', 'error');
                    
                    document.getElementById('match-result').innerHTML = `
                        <div style="color: #ef4444;">❌ 매칭 실패</div>
                        <div style="margin-top: 8px;">
                            <div>🎯 타겟 시간: ${targetTime.formatted}</div>
                            <div>📊 유효한 시간 데이터: ${validTimeCount}개</div>
                            <div style="color: #f59e0b; margin-top: 8px;">가능한 원인:</div>
                            <div style="margin-left: 16px;">
                                <div>• C열에 올바른 시간 형식 데이터 없음</div>
                                <div>• 타겟 시간과 유사한 시간대 데이터 부족</div>
                            </div>
                        </div>
                    `;
                }
                
                // 5단계: 결과 검증
                updateStepStatus(5, 'running');
                updateProgress(5);
                log('🔍 5단계: 결과 검증 시작', 'info');
                
                generateDiagnosis();
                
                updateStepStatus(5, 'success');
                log('✅ === 테스트 완료 ===', 'success');
                
            } catch (error) {
                log(`❌ 테스트 실패: ${error.message}`, 'error');
                generateDiagnosis();
            }
        }

        // 수동 CSV 테스트
        async function manualCSVTest() {
            const csvData = prompt(`CORS 문제로 자동 테스트가 실패했습니다.
수동으로 CSV 데이터를 테스트해보겠습니다.

다음 단계:
1. Google Sheets CSV URL을 새 탭에서 열기
2. 전체 CSV 내용을 복사해서 아래에 붙여넣기

CSV 데이터를 입력하세요:`, 
`Blinds,Cyprus,Seoul,#
100/200,13:30:25,14:30:25,1
150/300,13:35:45,14:35:45,2
200/400,13:40:15,14:40:15,3`);

            if (!csvData) {
                log('❌ 수동 테스트 취소됨', 'warning');
                return;
            }

            log('📋 === 수동 CSV 테스트 시작 ===', 'info');
            
            // 진행도 초기화
            updateProgress(2); // 처음 2단계 스킵
            updateStepStatus(1, 'success');
            updateStepStatus(2, 'success');
            
            testResults = {
                csvText: csvData,
                urlValidation: { valid: true, type: 'manual', message: '수동 입력' },
                httpResponse: { status: 200, statusText: 'OK (Manual)', ok: true }
            };

            document.getElementById('csv-preview').innerHTML = `
                <div style="color: #10b981;">✅ 수동 입력 데이터</div>
                <pre style="white-space: pre-wrap; margin-top: 4px; color: #e2e8f0;">${csvData}</pre>
            `;

            try {
                // 3단계: 데이터 파싱
                updateStepStatus(3, 'running');
                updateProgress(3);
                
                const rows = parseCSV(csvData);
                testResults.parsedRows = rows;
                log(`📋 파싱된 행 수: ${rows.length}`, 'success');
                updateStepStatus(3, 'success');

                // 4단계: 시간 매칭
                updateStepStatus(4, 'running');
                updateProgress(4);
                
                const targetTimeStr = document.getElementById('target-time').value;
                const targetTime = parseTimeString(targetTimeStr);
                
                if (!targetTime) {
                    throw new Error(`타겟 시간 파싱 실패: ${targetTimeStr}`);
                }

                log(`🎯 타겟 시간: ${targetTime.formatted}`, 'info');

                let closestRow = null;
                let minDiff = Infinity;
                let rowIndex = -1;
                let matchedTime = null;
                let validTimeCount = 0;

                for (let i = 0; i < rows.length; i++) {
                    const cellValue = rows[i][2]; // C열
                    if (!cellValue || !cellValue.trim()) continue;

                    const cellTime = parseTimeString(cellValue);
                    if (!cellTime) continue;

                    validTimeCount++;
                    const diff = Math.abs(cellTime.totalSeconds - targetTime.totalSeconds);

                    if (diff < minDiff) {
                        minDiff = diff;
                        closestRow = rows[i];
                        rowIndex = i + 1;
                        matchedTime = cellTime;

                        if (diff <= 5) break;
                    }
                }

                if (closestRow) {
                    updateStepStatus(4, 'success');
                    const accuracy = minDiff <= 5 ? '정확' : minDiff <= 30 ? '근사' : '대략적';
                    log(`✅ 매칭 성공: 행 ${rowIndex}, 시간 ${matchedTime.formatted}, 정확도 ${accuracy}`, 'success');
                    
                    document.getElementById('match-result').innerHTML = `
                        <div style="color: #10b981;">✅ 매칭 성공!</div>
                        <div style="margin-top: 8px;">
                            <div>📍 위치: 행 ${rowIndex}</div>
                            <div>🎯 타겟 시간: ${targetTime.formatted}</div>
                            <div>🕐 매칭된 시간: ${matchedTime.formatted}</div>
                            <div>⏰ 시간 차이: ${minDiff}초</div>
                            <div>📊 정확도: ${accuracy}</div>
                        </div>
                    `;
                } else {
                    updateStepStatus(4, 'error');
                    log('❌ 매칭 실패', 'error');
                }

                // 5단계 완료
                updateStepStatus(5, 'success');
                updateProgress(5);
                log('✅ === 수동 테스트 완료 ===', 'success');

            } catch (error) {
                log(`❌ 수동 테스트 실패: ${error.message}`, 'error');
            }
        }

        // 문제 진단 생성
        function generateDiagnosis() {
            let html = '<div style="color: #3b82f6; font-weight: bold;">🔍 자동 진단 결과</div><div style="margin-top: 12px;">';
            
            if (testResults.urlValidation) {
                const url = testResults.urlValidation;
                html += `<div><span style="color: #f59e0b;">URL 검증:</span> ${url.message}</div>`;
            }
            
            if (testResults.httpResponse) {
                const http = testResults.httpResponse;
                html += `<div><span style="color: #f59e0b;">HTTP 응답:</span> ${http.status} ${http.statusText}</div>`;
            }
            
            if (testResults.matching) {
                const m = testResults.matching;
                html += `<div><span style="color: #f59e0b;">시간 매칭:</span> 유효한 시간 ${m.validTimeCount}개 ${m.success ? '✅' : '❌'}</div>`;
            }
            
            html += '</div>';
            document.getElementById('diagnosis-result').innerHTML = html;
        }

        // 로그 지우기
        function clearLogs() {
            document.getElementById('log-output').innerHTML = '<div class="text-gray-400">로그가 지워졌습니다.</div>';
            document.getElementById('csv-preview').innerHTML = '<div class="text-gray-400">CSV 데이터를 불러오면 여기에 표시됩니다.</div>';
            document.getElementById('match-result').innerHTML = '<div class="text-gray-400">매칭 결과가 여기에 표시됩니다.</div>';
            document.getElementById('diagnosis-result').innerHTML = '<div class="text-gray-400">테스트 완료 후 문제 진단 결과가 표시됩니다.</div>';
            
            updateProgress(0);
            for (let i = 1; i <= totalSteps; i++) {
                updateStepStatus(i, 'pending');
            }
        }

        // DOM 로드 후 이벤트 리스너 등록
        document.addEventListener('DOMContentLoaded', function() {
            // URL 실시간 검증
            document.getElementById('sheets-url').addEventListener('input', function(e) {
                const url = e.target.value;
                const feedback = document.getElementById('url-feedback');
                
                if (!url) {
                    e.target.className = 'url-input';
                    feedback.textContent = '';
                    return;
                }
                
                const validation = validateGoogleSheetsUrl(url);
                let cssClass = 'url-input';
                
                if (validation.valid) {
                    cssClass += validation.warning ? ' url-warning' : ' url-valid';
                } else {
                    cssClass += ' url-error';
                }
                
                e.target.className = cssClass;
                feedback.textContent = validation.message;
            });

            // 버튼 이벤트 리스너
            document.getElementById('start-test').addEventListener('click', runTest);
            document.getElementById('manual-csv-test').addEventListener('click', manualCSVTest);
            document.getElementById('clear-logs').addEventListener('click', clearLogs);
        });
    </script>
</body>
</html>