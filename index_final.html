<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Table DB - Final Integration v10.5.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .metric-card {
            transition: all 0.3s ease;
        }
        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .status-connected { background-color: #10b981; animation: pulse 2s infinite; }
        .status-connecting { background-color: #f59e0b; animation: blink 1s infinite; }
        .status-disconnected { background-color: #ef4444; }
        .status-offline { background-color: #6b7280; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .data-table {
            font-size: 12px;
        }

        .row-added {
            background-color: rgba(16, 185, 129, 0.2);
            animation: highlight 1s ease-out;
        }

        .row-modified {
            background-color: rgba(59, 130, 246, 0.2);
            animation: highlight 1s ease-out;
        }

        .row-deleted {
            background-color: rgba(239, 68, 68, 0.2);
            animation: slideOut 0.5s ease-out;
        }

        .conflict-indicator {
            background-color: rgba(245, 158, 11, 0.3);
            border-left: 4px solid #f59e0b;
        }

        .offline-banner {
            background: linear-gradient(90deg, #374151, #4b5563);
            border-left: 4px solid #f59e0b;
        }

        @keyframes highlight {
            0% { background-color: rgba(255, 255, 255, 0.3); }
            100% { background-color: transparent; }
        }

        @keyframes slideOut {
            0% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(-100%); }
        }

        .mode-badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            text-transform: uppercase;
            font-weight: bold;
        }

        .mode-websocket { background: #10b981; color: white; }
        .mode-adaptive { background: #3b82f6; color: white; }
        .mode-incremental { background: #8b5cf6; color: white; }
        .mode-checksum { background: #f59e0b; color: white; }
        .mode-legacy { background: #6b7280; color: white; }
        .mode-offline { background: #ef4444; color: white; }
    </style>
</head>
<body class="bg-gray-900 text-white">
    <!-- 오프라인 배너 -->
    <div id="offline-banner" class="offline-banner p-3 text-center text-sm hidden">
        <span class="status-indicator status-offline"></span>
        <strong>오프라인 모드</strong> - 로컬 캐시 사용 중. <span id="pending-changes">0</span>개 변경사항 대기 중
    </div>

    <!-- 헤더 -->
    <div class="border-b border-gray-700 p-4">
        <div class="max-w-7xl mx-auto flex justify-between items-center">
            <div>
                <h1 class="text-2xl font-bold">Virtual Table DB</h1>
                <p class="text-gray-400">Final Integration v10.5.0</p>
            </div>
            <div class="flex items-center space-x-6">
                <!-- 연결 상태 -->
                <div class="flex items-center space-x-4">
                    <div id="connection-status" class="flex items-center">
                        <span id="connection-indicator" class="status-indicator status-disconnected"></span>
                        <div class="flex flex-col">
                            <span id="connection-text" class="text-sm">연결 중...</span>
                            <span id="connection-mode" class="mode-badge mode-adaptive">적응형</span>
                        </div>
                    </div>

                    <!-- 동기화 상태 -->
                    <div id="sync-status" class="flex items-center">
                        <span id="sync-indicator" class="status-indicator status-disconnected"></span>
                        <div class="flex flex-col">
                            <span id="sync-text" class="text-sm">동기화 대기</span>
                            <span id="sync-latency" class="text-xs text-gray-400">-</span>
                        </div>
                    </div>
                </div>

                <!-- 제어 버튼 -->
                <div class="flex items-center space-x-2">
                    <button id="force-sync" class="bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded text-sm">
                        강제 동기화
                    </button>
                    <button id="toggle-offline" class="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded text-sm">
                        오프라인 모드
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="max-w-7xl mx-auto p-6">
        <!-- 시스템 상태 대시보드 -->
        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6 mb-6">
            <!-- 연결 관리 -->
            <div class="bg-gray-800 rounded-lg p-6">
                <h3 class="text-lg font-semibold mb-4">🌐 연결 관리</h3>
                <div class="space-y-3">
                    <div class="flex justify-between text-sm">
                        <span>연결 모드:</span>
                        <span id="current-mode" class="font-bold">적응형</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span>폴링 간격:</span>
                        <span id="polling-interval">10초</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span>WebSocket:</span>
                        <span id="websocket-status" class="font-bold text-yellow-400">연결 중</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span>오프라인 캐시:</span>
                        <span id="cache-status" class="font-bold text-green-400">활성</span>
                    </div>
                </div>
            </div>

            <!-- 성능 메트릭 -->
            <div class="bg-gray-800 rounded-lg p-6">
                <h3 class="text-lg font-semibold mb-4">📊 성능 메트릭</h3>
                <div class="space-y-3">
                    <div class="flex justify-between text-sm">
                        <span>응답 시간:</span>
                        <span id="response-time-avg" class="font-bold text-green-400">15ms</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span>데이터 절약:</span>
                        <span id="data-savings" class="font-bold text-blue-400">96%</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span>폴링 효율:</span>
                        <span id="polling-efficiency" class="font-bold text-purple-400">62%</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span>배터리 절약:</span>
                        <span id="battery-savings" class="font-bold text-orange-400">45%</span>
                    </div>
                </div>
            </div>

            <!-- 활동 모니터 -->
            <div class="bg-gray-800 rounded-lg p-6">
                <h3 class="text-lg font-semibold mb-4">👤 사용자 활동</h3>
                <div class="space-y-3">
                    <div class="flex justify-between text-sm">
                        <span>현재 상태:</span>
                        <span id="user-activity-state" class="font-bold text-green-400">활성</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span>활동 점수:</span>
                        <span id="activity-score">75</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span>상태 변경:</span>
                        <span id="state-changes">12</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span>마지막 편집:</span>
                        <span id="last-edit">2분 전</span>
                    </div>
                </div>
            </div>

            <!-- 동기화 상태 -->
            <div class="bg-gray-800 rounded-lg p-6">
                <h3 class="text-lg font-semibold mb-4">🔄 동기화 상태</h3>
                <div class="space-y-3">
                    <div class="flex justify-between text-sm">
                        <span>마지막 동기화:</span>
                        <span id="last-sync">방금 전</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span>대기 중 변경:</span>
                        <span id="pending-sync-changes" class="font-bold text-yellow-400">0</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span>충돌 해결:</span>
                        <span id="conflicts-resolved">3</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span>동기화 성공률:</span>
                        <span id="sync-success-rate" class="font-bold text-green-400">98%</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- 실시간 통계 -->
        <div class="grid grid-cols-2 lg:grid-cols-6 gap-4 mb-6">
            <div class="metric-card bg-gray-800 rounded-lg p-4">
                <div class="text-xs text-gray-400 mb-1">총 API 호출</div>
                <div id="total-api-calls" class="text-xl font-bold text-blue-400">1,247</div>
            </div>
            <div class="metric-card bg-gray-800 rounded-lg p-4">
                <div class="text-xs text-gray-400 mb-1">데이터 전송량</div>
                <div id="total-data-transfer" class="text-xl font-bold text-purple-400">2.8MB</div>
            </div>
            <div class="metric-card bg-gray-800 rounded-lg p-4">
                <div class="text-xs text-gray-400 mb-1">평균 지연시간</div>
                <div id="average-latency" class="text-xl font-bold text-yellow-400">12ms</div>
            </div>
            <div class="metric-card bg-gray-800 rounded-lg p-4">
                <div class="text-xs text-gray-400 mb-1">운영 시간</div>
                <div id="uptime" class="text-xl font-bold text-green-400">2h 34m</div>
            </div>
            <div class="metric-card bg-gray-800 rounded-lg p-4">
                <div class="text-xs text-gray-400 mb-1">오프라인 시간</div>
                <div id="offline-time" class="text-xl font-bold text-red-400">0s</div>
            </div>
            <div class="metric-card bg-gray-800 rounded-lg p-4">
                <div class="text-xs text-gray-400 mb-1">효율성 점수</div>
                <div id="efficiency-score" class="text-xl font-bold text-cyan-400">A+</div>
            </div>
        </div>

        <!-- 모드 선택 및 설정 -->
        <div class="bg-gray-800 rounded-lg p-6 mb-6">
            <h3 class="text-lg font-semibold mb-4">⚙️ 시스템 설정</h3>
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <div>
                    <label class="block text-sm text-gray-400 mb-2">동기화 모드</label>
                    <select id="sync-mode" class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2">
                        <option value="websocket">WebSocket (실시간)</option>
                        <option value="adaptive" selected>적응형 폴링</option>
                        <option value="incremental">증분 업데이트</option>
                        <option value="checksum">체크섬 기반</option>
                        <option value="legacy">레거시 모드</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm text-gray-400 mb-2">충돌 해결 전략</label>
                    <select id="conflict-resolution" class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2">
                        <option value="server-wins" selected>서버 우선</option>
                        <option value="client-wins">클라이언트 우선</option>
                        <option value="merge">자동 병합</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm text-gray-400 mb-2">오프라인 설정</label>
                    <div class="flex items-center space-x-4">
                        <label class="flex items-center">
                            <input type="checkbox" id="auto-cache" checked class="mr-2">
                            <span class="text-sm">자동 캐시</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="auto-sync" checked class="mr-2">
                            <span class="text-sm">자동 동기화</span>
                        </label>
                    </div>
                </div>
            </div>
        </div>

        <!-- 데이터 테이블 -->
        <div class="bg-gray-800 rounded-lg overflow-hidden">
            <div class="p-4 border-b border-gray-700">
                <div class="flex justify-between items-center">
                    <h3 class="text-lg font-semibold">🗂️ 데이터 테이블</h3>
                    <div class="flex items-center space-x-4">
                        <span class="text-sm text-gray-400">마지막 업데이트: <span id="last-update">방금 전</span></span>
                        <div id="update-indicator" class="text-xs px-2 py-1 rounded bg-green-700 text-green-100">
                            실시간 동기화
                        </div>
                        <span class="text-sm text-gray-400">총 <span id="total-rows">0</span>행</span>
                    </div>
                </div>
            </div>
            <div class="overflow-x-auto">
                <table class="w-full data-table">
                    <thead>
                        <tr class="bg-gray-700 border-b border-gray-600">
                            <th class="p-2 text-left">#</th>
                            <th class="p-2 text-left">A</th>
                            <th class="p-2 text-left">B</th>
                            <th class="p-2 text-left">C</th>
                            <th class="p-2 text-left">D</th>
                            <th class="p-2 text-left">E</th>
                            <th class="p-2 text-left">F</th>
                            <th class="p-2 text-left">G</th>
                            <th class="p-2 text-left">H</th>
                            <th class="p-2 text-left">I</th>
                            <th class="p-2 text-left">J</th>
                            <th class="p-2 text-left">상태</th>
                        </tr>
                    </thead>
                    <tbody id="data-tbody">
                        <tr>
                            <td colspan="12" class="p-8 text-center text-gray-400">
                                시스템 초기화 중...
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- 스크립트 로드 -->
    <script src="performance_monitor.js"></script>
    <script src="incremental_manager.js"></script>
    <script src="adaptive_polling_manager.js"></script>
    <script src="websocket_manager.js"></script>
    <script src="offline_manager.js"></script>

    <script>
        // 전역 변수
        let performanceMonitor;
        let incrementalManager;
        let adaptivePollingManager;
        let webSocketManager;
        let offlineManager;

        let currentMode = 'adaptive';
        let isInitialized = false;

        // Apps Script URL (실제 URL로 교체 필요)
        const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec';

        // 초기화
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('🚀 Final Integration 시스템 초기화 시작');

            try {
                await initializeAllSystems();
                setupEventListeners();
                startMetricsUpdate();

                isInitialized = true;
                console.log('✅ 모든 시스템 초기화 완료');

                // 초기 데이터 로드
                await loadInitialData();

            } catch (error) {
                console.error('❌ 시스템 초기화 실패:', error);
                showErrorNotification('시스템 초기화에 실패했습니다.');
            }
        });

        // 모든 시스템 초기화
        async function initializeAllSystems() {
            // 1. 성능 모니터
            performanceMonitor = new PerformanceMonitor();

            // 2. 증분 업데이트 매니저
            incrementalManager = initializeIncrementalManager(APPS_SCRIPT_URL);

            // 3. 적응형 폴링 매니저
            adaptivePollingManager = initializeAdaptivePolling(incrementalManager);

            // 4. WebSocket 매니저
            webSocketManager = initializeWebSocketManager(APPS_SCRIPT_URL, adaptivePollingManager);

            // 5. 오프라인 매니저
            offlineManager = initializeOfflineManager(incrementalManager);

            console.log('📦 모든 매니저 초기화 완료');
        }

        // 이벤트 리스너 설정
        function setupEventListeners() {
            // 모드 변경
            document.getElementById('sync-mode').addEventListener('change', (e) => {
                switchSyncMode(e.target.value);
            });

            // 충돌 해결 전략 변경
            document.getElementById('conflict-resolution').addEventListener('change', (e) => {
                setConflictResolution(e.target.value);
            });

            // 강제 동기화
            document.getElementById('force-sync').addEventListener('click', () => {
                forceSync();
            });

            // 오프라인 모드 토글
            document.getElementById('toggle-offline').addEventListener('click', () => {
                toggleOfflineMode();
            });

            // 시스템 이벤트 리스너
            setupSystemEventListeners();
        }

        // 시스템 이벤트 리스너 설정
        function setupSystemEventListeners() {
            // WebSocket 이벤트
            if (webSocketManager) {
                webSocketManager.on('connected', () => {
                    updateConnectionStatus('websocket', 'connected');
                });

                webSocketManager.on('disconnected', () => {
                    updateConnectionStatus('websocket', 'disconnected');
                });

                webSocketManager.on('dataReceived', (data) => {
                    handleRealtimeData(data);
                });
            }

            // 오프라인 매니저 이벤트
            if (offlineManager) {
                offlineManager.on('offlineMode', (data) => {
                    showOfflineBanner(true, data.pendingChanges);
                });

                offlineManager.on('onlineMode', (data) => {
                    showOfflineBanner(false);
                });

                offlineManager.on('syncCompleted', (data) => {
                    updateSyncStatus(data);
                });
            }

            // 적응형 폴링 이벤트
            if (adaptivePollingManager) {
                adaptivePollingManager.on('stateChanged', (data) => {
                    updateActivityState(data.newState);
                });
            }
        }

        // 동기화 모드 전환
        async function switchSyncMode(mode) {
            if (currentMode === mode) return;

            console.log(`🔄 동기화 모드 전환: ${currentMode} → ${mode}`);

            // 현재 모드 중지
            await stopCurrentMode();

            // 새 모드 시작
            await startNewMode(mode);

            currentMode = mode;
            updateModeDisplay(mode);
        }

        // 현재 모드 중지
        async function stopCurrentMode() {
            switch (currentMode) {
                case 'websocket':
                    if (webSocketManager) {
                        webSocketManager.disconnect();
                    }
                    break;

                case 'adaptive':
                    if (adaptivePollingManager) {
                        adaptivePollingManager.stopPolling();
                    }
                    break;

                case 'incremental':
                case 'checksum':
                case 'legacy':
                    // 기본 폴링 중지
                    if (window.basicPollingTimer) {
                        clearInterval(window.basicPollingTimer);
                    }
                    break;
            }
        }

        // 새 모드 시작
        async function startNewMode(mode) {
            switch (mode) {
                case 'websocket':
                    if (webSocketManager) {
                        await webSocketManager.connect();
                    }
                    break;

                case 'adaptive':
                    if (adaptivePollingManager) {
                        adaptivePollingManager.startPolling();
                    }
                    break;

                case 'incremental':
                    startBasicPolling(10000, () => {
                        if (incrementalManager) {
                            incrementalManager.fetchUpdate();
                        }
                    });
                    break;

                case 'checksum':
                case 'legacy':
                    startBasicPolling(10000, () => {
                        console.log(`${mode} 폴링 실행`);
                    });
                    break;
            }
        }

        // 기본 폴링 시작
        function startBasicPolling(interval, callback) {
            window.basicPollingTimer = setInterval(callback, interval);
            console.log(`기본 폴링 시작: ${interval}ms`);
        }

        // 연결 상태 업데이트
        function updateConnectionStatus(type, status) {
            const indicator = document.getElementById('connection-indicator');
            const text = document.getElementById('connection-text');
            const mode = document.getElementById('connection-mode');

            switch (status) {
                case 'connected':
                    indicator.className = 'status-indicator status-connected';
                    text.textContent = type === 'websocket' ? 'WebSocket 연결됨' : '연결됨';
                    break;

                case 'connecting':
                    indicator.className = 'status-indicator status-connecting';
                    text.textContent = '연결 중...';
                    break;

                case 'disconnected':
                    indicator.className = 'status-indicator status-disconnected';
                    text.textContent = '연결 해제됨';
                    break;
            }

            // 모드 배지 업데이트
            updateModeDisplay(currentMode);
        }

        // 모드 표시 업데이트
        function updateModeDisplay(mode) {
            const modeElement = document.getElementById('connection-mode');
            const currentModeElement = document.getElementById('current-mode');

            const modeNames = {
                websocket: 'WebSocket',
                adaptive: '적응형',
                incremental: '증분',
                checksum: '체크섬',
                legacy: '레거시'
            };

            const modeClasses = {
                websocket: 'mode-websocket',
                adaptive: 'mode-adaptive',
                incremental: 'mode-incremental',
                checksum: 'mode-checksum',
                legacy: 'mode-legacy'
            };

            modeElement.className = `mode-badge ${modeClasses[mode]}`;
            modeElement.textContent = modeNames[mode];
            currentModeElement.textContent = modeNames[mode];
        }

        // 오프라인 배너 표시
        function showOfflineBanner(show, pendingChanges = 0) {
            const banner = document.getElementById('offline-banner');
            const pendingElement = document.getElementById('pending-changes');

            if (show) {
                banner.classList.remove('hidden');
                pendingElement.textContent = pendingChanges;
            } else {
                banner.classList.add('hidden');
            }
        }

        // 활동 상태 업데이트
        function updateActivityState(state) {
            const stateElement = document.getElementById('user-activity-state');
            const stateNames = {
                active: '활성',
                normal: '일반',
                idle: '대기',
                background: '백그라운드'
            };

            stateElement.textContent = stateNames[state] || state;
        }

        // 실시간 데이터 처리
        function handleRealtimeData(data) {
            console.log('📨 실시간 데이터 처리:', data.type);

            // 테이블 업데이트
            if (data.type === 'full') {
                updateDataTable(data.data);
            } else if (data.type === 'delta') {
                applyDeltaToTable(data.delta);
            }

            // 업데이트 인디케이터
            updateLastUpdateTime();
        }

        // 데이터 테이블 업데이트
        function updateDataTable(data) {
            const tbody = document.getElementById('data-tbody');
            tbody.innerHTML = '';

            data.forEach((row, index) => {
                const tr = document.createElement('tr');
                tr.className = 'border-b border-gray-700 hover:bg-gray-750';

                tr.innerHTML = `
                    <td class="p-2">${index + 1}</td>
                    ${row.map(cell => `<td class="p-2">${cell || '-'}</td>`).join('')}
                    <td class="p-2">
                        <span class="text-xs px-2 py-1 bg-green-700 rounded">동기화됨</span>
                    </td>
                `;

                tbody.appendChild(tr);
            });

            document.getElementById('total-rows').textContent = data.length;
        }

        // 마지막 업데이트 시간 갱신
        function updateLastUpdateTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            document.getElementById('last-update').textContent = timeString;
        }

        // 메트릭 업데이트
        function updateMetrics() {
            if (!isInitialized) return;

            // 성능 메트릭
            if (performanceMonitor) {
                const metrics = performanceMonitor.getMetrics();
                document.getElementById('total-api-calls').textContent = metrics.totalRequests;
                document.getElementById('average-latency').textContent = metrics.averageResponseTime.toFixed(0) + 'ms';
            }

            // 적응형 폴링 통계
            if (adaptivePollingManager) {
                const stats = adaptivePollingManager.getStats();
                document.getElementById('polling-efficiency').textContent = stats.efficiency;
            }

            // WebSocket 통계
            if (webSocketManager) {
                const stats = webSocketManager.getStats();
                document.getElementById('total-data-transfer').textContent = stats.dataTransferredMB + 'MB';
            }

            // 오프라인 통계
            if (offlineManager) {
                const stats = offlineManager.getStats();
                document.getElementById('pending-sync-changes').textContent = stats.averageQueueSize;
                document.getElementById('sync-success-rate').textContent = stats.syncSuccessRate;
            }
        }

        // 메트릭 업데이트 시작
        function startMetricsUpdate() {
            setInterval(updateMetrics, 1000);
        }

        // 초기 데이터 로드
        async function loadInitialData() {
            console.log('📂 초기 데이터 로드 시작');

            try {
                // 기본 모드로 시작
                await startNewMode(currentMode);

                // 테스트 데이터 표시
                const testData = [
                    ['데이터1', '값1', '타입A', '상태1', '메모1', '', '', '', '', ''],
                    ['데이터2', '값2', '타입B', '상태2', '메모2', '', '', '', '', ''],
                    ['데이터3', '값3', '타입C', '상태3', '메모3', '', '', '', '', '']
                ];

                updateDataTable(testData);
                updateLastUpdateTime();

            } catch (error) {
                console.error('❌ 초기 데이터 로드 실패:', error);
            }
        }

        // 유틸리티 함수들
        function forceSync() {
            console.log('🔄 강제 동기화 실행');
            if (offlineManager) {
                offlineManager.forcSync();
            }
        }

        function toggleOfflineMode() {
            console.log('📵 오프라인 모드 토글');
            // 네트워크 상태 시뮬레이션
            if (navigator.onLine) {
                showOfflineBanner(true, 5);
            } else {
                showOfflineBanner(false);
            }
        }

        function setConflictResolution(strategy) {
            console.log(`⚖️ 충돌 해결 전략 변경: ${strategy}`);
            if (offlineManager) {
                offlineManager.setConflictResolution(strategy);
            }
        }

        function showErrorNotification(message) {
            // 간단한 에러 알림 (실제로는 더 정교한 알림 시스템 구현)
            alert('오류: ' + message);
        }

        // 전역 함수로 등록
        window.updateConnectionStatus = updateConnectionStatus;
        window.handleRealtimeData = handleRealtimeData;
        window.updateSyncStatus = updateSyncStatus;
        window.showConflictNotification = showConflictNotification;
        window.updateLatencyMetrics = updateLatencyMetrics;
        window.updateOfflineStatus = updateOfflineStatus;

        // 빈 함수들 (나중에 구현)
        function updateSyncStatus(data) {}
        function showConflictNotification(data) {}
        function updateLatencyMetrics(data) {}
        function updateOfflineStatus(isOffline, data) {}
    </script>
</body>
</html>