<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>시간 매칭 테스트</title>
</head>
<body>
    <h1>시간 매칭 로직 테스트</h1>
    <pre id="output"></pre>

    <script>
        // 테스트 출력 함수
        const output = document.getElementById('output');
        function log(msg) {
            output.textContent += msg + '\n';
            console.log(msg);
        }

        // parseCSV 함수 (메인 코드에서 복사)
        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const rows = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].replace(/\r/g, '');
                if (!line.trim()) continue;

                const row = [];
                let inQuotes = false;
                let currentField = '';

                for (let j = 0; j < line.length; j++) {
                    const char = line[j];
                    const nextChar = line[j + 1];

                    if (char === '"') {
                        if (inQuotes && nextChar === '"') {
                            currentField += '"';
                            j++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        row.push(currentField.trim());
                        currentField = '';
                    } else {
                        currentField += char;
                    }
                }
                row.push(currentField.trim());
                rows.push(row);
            }

            return rows;
        }

        // 시간 파싱 함수
        function parseTimeToTimestamp(timeStr) {
            if (!timeStr) return null;

            const str = String(timeStr).trim();

            // 이미 타임스탬프인 경우
            const numValue = parseInt(str);
            if (!isNaN(numValue) && numValue > 1000000000 && str.match(/^\d+$/)) {
                return numValue;
            }

            // HH:MM:SS 또는 HH:MM 형식
            const timeParts = str.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
            if (timeParts) {
                const today = new Date();
                const hours = parseInt(timeParts[1]);
                const minutes = parseInt(timeParts[2]);
                const seconds = parseInt(timeParts[3] || 0);

                today.setHours(hours, minutes, seconds, 0);

                const now = new Date();
                if (today > now) {
                    today.setDate(today.getDate() - 1);
                }

                return Math.floor(today.getTime() / 1000);
            }

            log(`⚠️ 시간 파싱 실패: "${str}"`);
            return null;
        }

        async function runTest() {
            log('🧪 시간 매칭 테스트 시작\n');

            // Virtual 시트 CSV 가져오기
            const csvUrl = 'https://docs.google.com/spreadsheets/d/1M-LM2KkwLNOTygtrPVdnYLqqBoz4MmZvbglUaptSYqE/export?format=csv&gid=561799849';

            log('📥 CSV 데이터 가져오기...');
            const response = await fetch(csvUrl);
            const csvText = await response.text();

            log(`✅ CSV 크기: ${csvText.length} bytes\n`);

            // CSV 파싱
            const rows = parseCSV(csvText);
            log(`📊 파싱된 행 수: ${rows.length}개\n`);

            // 618-622행 데이터 확인
            log('🔍 618-622행 데이터 분석:');
            for (let i = 617; i < 623 && i < rows.length; i++) {
                const row = rows[i];
                if (row && row.length > 4) {
                    log(`   행 ${i+1}: B열="${row[1] || ''}", E열="${row[4] || ''}"`);
                }
            }

            // 시간 캐시 구축
            log('\n📋 시간 데이터 캐싱:');
            const cache = new Map();
            const timeIndex = new Map();

            for (let i = 0; i < rows.length && i < 1000; i++) {
                const cols = rows[i];
                if (!cols || cols.length < 8) continue;

                const timeStr = cols[1]?.trim();
                if (!timeStr) continue;

                const timestamp = parseTimeToTimestamp(timeStr);
                if (!timestamp) continue;

                let status = cols[4]?.trim() || '';
                if (status.startsWith('"') && status.endsWith('"')) {
                    status = status.slice(1, -1);
                }

                const rowData = {
                    row: i + 1,
                    time: timeStr,
                    timestamp: timestamp,
                    status: status
                };

                cache.set(i + 1, rowData);

                if (!timeIndex.has(timestamp)) {
                    timeIndex.set(timestamp, []);
                }
                timeIndex.get(timestamp).push(i + 1);

                // 618-622행 근처만 로그
                if (i >= 617 && i < 623) {
                    log(`   캐시 저장: 행 ${i+1}, 시간="${timeStr}", 상태="${status}", 타임스탬프=${timestamp}`);
                }
            }

            log(`\n✅ 캐시 크기: ${cache.size}개`);
            log(`✅ 시간 인덱스: ${timeIndex.size}개\n`);

            // 10:18 찾기
            log('🎯 10:18 매칭 테스트:');

            // Hand 시트의 타임스탬프 (핸드 #138)
            const handTimestamp = 1758075882; // 2025-09-17 10:18:02
            const handDate = new Date(handTimestamp * 1000);
            const targetHours = handDate.getHours();
            const targetMinutes = handDate.getMinutes();
            const targetTimeString = `${targetHours.toString().padStart(2, '0')}:${targetMinutes.toString().padStart(2, '0')}`;

            log(`   Hand 타임스탬프: ${handTimestamp}`);
            log(`   목표 시간: ${targetTimeString}\n`);

            // 정확한 매칭 찾기
            let exactMatch = null;
            for (const [rowNum, data] of cache) {
                if (data.time === targetTimeString) {
                    exactMatch = data;
                    log(`   ✅ 정확한 매칭 발견: 행 ${rowNum}, 시간="${data.time}", 상태="${data.status}"`);
                    break;
                }
            }

            if (!exactMatch) {
                log(`   ❌ 정확한 매칭 없음\n`);

                // 근사 매칭 시도
                log('   🔄 근사 매칭 시도 (±3분):');
                const targetTotalMinutes = targetHours * 60 + targetMinutes;

                let closestMatch = null;
                let minDiff = Infinity;

                for (const [rowNum, data] of cache) {
                    const timeParts = data.time.match(/(\d+):(\d+)/);
                    if (timeParts) {
                        const hours = parseInt(timeParts[1]);
                        const minutes = parseInt(timeParts[2]);
                        const totalMinutes = hours * 60 + minutes;
                        const diff = Math.abs(totalMinutes - targetTotalMinutes);

                        if (diff <= 5) {
                            log(`      행 ${rowNum}: 시간="${data.time}" (${diff}분 차이), 상태="${data.status}"`);

                            if (diff < minDiff) {
                                minDiff = diff;
                                closestMatch = data;
                            }
                        }
                    }
                }

                if (closestMatch) {
                    log(`\n   🎯 최종 선택: 행 ${closestMatch.row}, 시간="${closestMatch.time}", 상태="${closestMatch.status}"`);
                }
            }

            // "10:18" 문자열이 캐시에 있는지 직접 확인
            log('\n🔍 "10:18" 문자열 직접 검색:');
            let found1018 = false;
            for (const [rowNum, data] of cache) {
                if (data.time.includes('10:18')) {
                    log(`   발견: 행 ${rowNum}, 시간="${data.time}", 상태="${data.status}"`);
                    found1018 = true;
                }
            }
            if (!found1018) {
                log('   ❌ "10:18"을 포함하는 행이 없음');
            }

            // "10:14" 확인
            log('\n🔍 "10:14" 문자열 검색:');
            for (const [rowNum, data] of cache) {
                if (data.time.includes('10:14')) {
                    log(`   발견: 행 ${rowNum}, 시간="${data.time}", 상태="${data.status}"`);
                    break;
                }
            }

            log('\n🧪 테스트 완료');
        }

        // 테스트 실행
        runTest().catch(err => {
            log('❌ 오류: ' + err.message);
            console.error(err);
        });
    </script>
</body>
</html>