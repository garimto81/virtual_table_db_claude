<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phase 3 테스트 - v11.2.0</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 10px;
      margin-bottom: 30px;
    }
    .test-section {
      background: white;
      padding: 25px;
      border-radius: 10px;
      margin-bottom: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .test-title {
      font-size: 20px;
      font-weight: bold;
      color: #333;
      margin-bottom: 15px;
      border-bottom: 2px solid #667eea;
      padding-bottom: 10px;
    }
    .test-controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 15px 0;
    }
    button {
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    .btn-primary {
      background: #667eea;
      color: white;
    }
    .btn-primary:hover {
      background: #5a67d8;
      transform: translateY(-2px);
    }
    .btn-success {
      background: #48bb78;
      color: white;
    }
    .btn-danger {
      background: #f56565;
      color: white;
    }
    .btn-warning {
      background: #ed8936;
      color: white;
    }
    .test-output {
      background: #f7fafc;
      padding: 15px;
      border-radius: 5px;
      margin-top: 15px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #e2e8f0;
    }
    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 5px;
    }
    .status-active {
      background: #48bb78;
      animation: pulse 2s infinite;
    }
    .status-inactive {
      background: #cbd5e0;
    }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }
    .metric-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
    }
    .metric-value {
      font-size: 24px;
      font-weight: bold;
      margin-top: 5px;
    }
    .test-result {
      padding: 8px;
      margin: 5px 0;
      border-radius: 5px;
    }
    .test-pass {
      background: #c6f6d5;
      color: #22543d;
    }
    .test-fail {
      background: #fed7d7;
      color: #742a2a;
    }
    .test-pending {
      background: #feebc8;
      color: #744210;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>🚀 Phase 3 성능 테스트 대시보드</h1>
    <p>Version 11.2.0 - 스마트 새로고침 및 로컬 저장소 테스트</p>
    <p>테스트 시간: <span id="test-time"></span></p>
  </div>

  <!-- Phase 3-A: SmartRefreshManager 테스트 -->
  <div class="test-section">
    <div class="test-title">
      <span class="status-indicator status-inactive" id="smart-refresh-status"></span>
      Phase 3-A: SmartRefreshManager 테스트
    </div>
    <div class="test-controls">
      <button class="btn-primary" onclick="testSmartRefresh()">스마트 새로고침 테스트</button>
      <button class="btn-success" onclick="simulateActivity()">활동 시뮬레이션</button>
      <button class="btn-warning" onclick="simulateInactivity()">비활동 시뮬레이션</button>
      <button class="btn-danger" onclick="toggleSmartRefresh()">토글 ON/OFF</button>
    </div>
    <div class="metrics-grid">
      <div class="metric-card">
        <div>현재 간격</div>
        <div class="metric-value" id="current-interval">30초</div>
      </div>
      <div class="metric-card">
        <div>활동 상태</div>
        <div class="metric-value" id="activity-status">비활동</div>
      </div>
      <div class="metric-card">
        <div>새로고침 횟수</div>
        <div class="metric-value" id="refresh-count">0</div>
      </div>
    </div>
    <div class="test-output" id="smart-refresh-output"></div>
  </div>

  <!-- Phase 3-B: LocalDataStore (IndexedDB) 테스트 -->
  <div class="test-section">
    <div class="test-title">
      <span class="status-indicator status-inactive" id="indexeddb-status"></span>
      Phase 3-B: LocalDataStore (IndexedDB) 테스트
    </div>
    <div class="test-controls">
      <button class="btn-primary" onclick="testIndexedDB()">IndexedDB 테스트</button>
      <button class="btn-success" onclick="saveTestData()">테스트 데이터 저장</button>
      <button class="btn-warning" onclick="loadTestData()">테스트 데이터 로드</button>
      <button class="btn-danger" onclick="clearIndexedDB()">IndexedDB 초기화</button>
    </div>
    <div class="metrics-grid">
      <div class="metric-card">
        <div>저장소 크기</div>
        <div class="metric-value" id="storage-size">0 KB</div>
      </div>
      <div class="metric-card">
        <div>저장된 핸드</div>
        <div class="metric-value" id="stored-hands">0</div>
      </div>
      <div class="metric-card">
        <div>캐시된 행</div>
        <div class="metric-value" id="cached-rows">0</div>
      </div>
    </div>
    <div class="test-output" id="indexeddb-output"></div>
  </div>

  <!-- Phase 3-C: 통합 성능 테스트 -->
  <div class="test-section">
    <div class="test-title">
      <span class="status-indicator status-inactive" id="performance-status"></span>
      Phase 3-C: 통합 성능 테스트
    </div>
    <div class="test-controls">
      <button class="btn-primary" onclick="runFullTest()">전체 테스트 실행</button>
      <button class="btn-success" onclick="testOfflineMode()">오프라인 모드 테스트</button>
      <button class="btn-warning" onclick="testMemoryUsage()">메모리 사용량 테스트</button>
    </div>
    <div class="test-output" id="performance-output"></div>
  </div>

  <!-- 테스트 결과 요약 -->
  <div class="test-section">
    <div class="test-title">📊 테스트 결과 요약</div>
    <div id="test-summary">
      <div class="test-result test-pending">테스트를 시작하려면 위의 버튼을 클릭하세요.</div>
    </div>
  </div>

  <script>
    // 전역 변수
    let smartRefreshManager = null;
    let localDataStore = null;
    let refreshCount = 0;
    let testResults = [];

    // 페이지 로드 시 초기화
    document.addEventListener('DOMContentLoaded', () => {
      updateTestTime();
      initializePhase3Components();
    });

    function updateTestTime() {
      const now = new Date();
      document.getElementById('test-time').textContent = now.toLocaleString('ko-KR');
    }

    function log(section, message, isError = false) {
      const output = document.getElementById(section + '-output');
      const timestamp = new Date().toLocaleTimeString();
      const color = isError ? 'color: #e53e3e;' : 'color: #2d3748;';
      output.innerHTML += `<div style="${color}">[${timestamp}] ${message}</div>`;
      output.scrollTop = output.scrollHeight;
    }

    // Phase 3 컴포넌트 초기화
    async function initializePhase3Components() {
      try {
        // SmartRefreshManager 초기화
        smartRefreshManager = {
          refreshInterval: 30000,
          minInterval: 10000,
          maxInterval: 300000,
          isActive: false,
          isEnabled: false,
          lastActivity: Date.now(),

          detectActivity() {
            this.lastActivity = Date.now();
            this.isActive = true;
            this.adjustInterval();
          },

          adjustInterval() {
            if (this.isActive) {
              this.refreshInterval = Math.max(this.minInterval, this.refreshInterval * 0.5);
            } else {
              this.refreshInterval = Math.min(this.maxInterval, this.refreshInterval * 1.5);
            }
            document.getElementById('current-interval').textContent = `${Math.round(this.refreshInterval/1000)}초`;
          },

          toggle() {
            this.isEnabled = !this.isEnabled;
            const statusEl = document.getElementById('smart-refresh-status');
            if (this.isEnabled) {
              statusEl.classList.add('status-active');
              statusEl.classList.remove('status-inactive');
            } else {
              statusEl.classList.remove('status-active');
              statusEl.classList.add('status-inactive');
            }
            return this.isEnabled;
          }
        };

        // LocalDataStore 초기화
        if ('indexedDB' in window) {
          const request = indexedDB.open('TestPokerDB', 1);

          request.onupgradeneeded = (event) => {
            const db = event.target.result;

            if (!db.objectStoreNames.contains('hands')) {
              db.createObjectStore('hands', { keyPath: 'handNumber' });
            }
            if (!db.objectStoreNames.contains('sheetCache')) {
              const store = db.createObjectStore('sheetCache', { keyPath: 'rowNumber' });
              store.createIndex('timestamp', 'timestamp', { unique: false });
            }
            if (!db.objectStoreNames.contains('settings')) {
              db.createObjectStore('settings', { keyPath: 'key' });
            }
          };

          request.onsuccess = (event) => {
            localDataStore = {
              db: event.target.result,

              async saveHand(hand) {
                return new Promise((resolve, reject) => {
                  const transaction = this.db.transaction(['hands'], 'readwrite');
                  const store = transaction.objectStore('hands');
                  const request = store.put(hand);
                  request.onsuccess = () => resolve(true);
                  request.onerror = () => reject(request.error);
                });
              },

              async getStorageSize() {
                if (navigator.storage?.estimate) {
                  const estimate = await navigator.storage.estimate();
                  return estimate.usage || 0;
                }
                return 0;
              },

              async clearAll() {
                return new Promise((resolve, reject) => {
                  const transaction = this.db.transaction(['hands', 'sheetCache', 'settings'], 'readwrite');
                  transaction.objectStore('hands').clear();
                  transaction.objectStore('sheetCache').clear();
                  transaction.objectStore('settings').clear();
                  transaction.oncomplete = () => resolve();
                  transaction.onerror = () => reject(transaction.error);
                });
              }
            };

            document.getElementById('indexeddb-status').classList.add('status-active');
            document.getElementById('indexeddb-status').classList.remove('status-inactive');
            log('indexeddb', '✅ IndexedDB 초기화 성공');
          };

          request.onerror = () => {
            log('indexeddb', '❌ IndexedDB 초기화 실패', true);
          };
        } else {
          log('indexeddb', '⚠️ 브라우저가 IndexedDB를 지원하지 않습니다', true);
        }

        log('smart-refresh', '✅ Phase 3 컴포넌트 초기화 완료');
      } catch (error) {
        log('performance', `❌ 초기화 오류: ${error.message}`, true);
      }
    }

    // SmartRefreshManager 테스트
    async function testSmartRefresh() {
      log('smart-refresh', '🔄 SmartRefreshManager 테스트 시작...');

      const tests = [
        { name: '초기 상태 확인', passed: smartRefreshManager !== null },
        { name: '새로고침 간격 조정', passed: true },
        { name: '활동 감지', passed: true },
        { name: '토글 기능', passed: true }
      ];

      // 간격 조정 테스트
      const initialInterval = smartRefreshManager.refreshInterval;
      smartRefreshManager.detectActivity();
      tests[1].passed = smartRefreshManager.refreshInterval < initialInterval;

      // 활동 감지 테스트
      const lastActivity = smartRefreshManager.lastActivity;
      await new Promise(resolve => setTimeout(resolve, 100));
      smartRefreshManager.detectActivity();
      tests[2].passed = smartRefreshManager.lastActivity > lastActivity;

      // 토글 테스트
      const wasEnabled = smartRefreshManager.isEnabled;
      smartRefreshManager.toggle();
      tests[3].passed = smartRefreshManager.isEnabled !== wasEnabled;
      smartRefreshManager.toggle(); // 원상복구

      // 결과 표시
      tests.forEach(test => {
        const status = test.passed ? '✅' : '❌';
        log('smart-refresh', `${status} ${test.name}`);
      });

      updateTestSummary('SmartRefreshManager', tests);
    }

    function simulateActivity() {
      smartRefreshManager.detectActivity();
      document.getElementById('activity-status').textContent = '활동중';
      log('smart-refresh', '👆 사용자 활동 시뮬레이션');

      setTimeout(() => {
        document.getElementById('activity-status').textContent = '비활동';
        smartRefreshManager.isActive = false;
        smartRefreshManager.adjustInterval();
      }, 5000);
    }

    function simulateInactivity() {
      smartRefreshManager.isActive = false;
      smartRefreshManager.adjustInterval();
      document.getElementById('activity-status').textContent = '비활동';
      log('smart-refresh', '💤 비활동 상태 시뮬레이션');
    }

    function toggleSmartRefresh() {
      const enabled = smartRefreshManager.toggle();
      log('smart-refresh', `🔄 스마트 새로고침: ${enabled ? 'ON' : 'OFF'}`);

      if (enabled) {
        simulateRefreshCycle();
      }
    }

    function simulateRefreshCycle() {
      if (!smartRefreshManager.isEnabled) return;

      refreshCount++;
      document.getElementById('refresh-count').textContent = refreshCount;
      log('smart-refresh', `🔄 새로고침 #${refreshCount} 실행 (간격: ${Math.round(smartRefreshManager.refreshInterval/1000)}초)`);

      setTimeout(() => simulateRefreshCycle(), smartRefreshManager.refreshInterval);
    }

    // IndexedDB 테스트
    async function testIndexedDB() {
      log('indexeddb', '🔄 IndexedDB 테스트 시작...');

      const tests = [
        { name: 'DB 연결 상태', passed: localDataStore && localDataStore.db !== null },
        { name: '데이터 저장', passed: false },
        { name: '데이터 조회', passed: false },
        { name: '저장소 크기 확인', passed: false },
        { name: '데이터 삭제', passed: false }
      ];

      try {
        // 데이터 저장 테스트
        await localDataStore.saveHand({ handNumber: 'TEST-001', data: 'test data' });
        tests[1].passed = true;

        // 데이터 조회 테스트
        const transaction = localDataStore.db.transaction(['hands'], 'readonly');
        const store = transaction.objectStore('hands');
        const request = store.get('TEST-001');
        await new Promise((resolve, reject) => {
          request.onsuccess = () => {
            tests[2].passed = request.result !== undefined;
            resolve();
          };
          request.onerror = reject;
        });

        // 저장소 크기 확인
        const size = await localDataStore.getStorageSize();
        tests[3].passed = size >= 0;
        document.getElementById('storage-size').textContent = `${Math.round(size/1024)} KB`;

        // 데이터 삭제 테스트
        await localDataStore.clearAll();
        tests[4].passed = true;

      } catch (error) {
        log('indexeddb', `❌ 테스트 오류: ${error.message}`, true);
      }

      // 결과 표시
      tests.forEach(test => {
        const status = test.passed ? '✅' : '❌';
        log('indexeddb', `${status} ${test.name}`);
      });

      updateTestSummary('IndexedDB', tests);
    }

    async function saveTestData() {
      try {
        const testData = [];
        for (let i = 1; i <= 10; i++) {
          testData.push({
            handNumber: `HAND-${i.toString().padStart(3, '0')}`,
            timestamp: Date.now() - (i * 60000),
            pot: Math.floor(Math.random() * 1000),
            players: 6
          });
        }

        for (const hand of testData) {
          await localDataStore.saveHand(hand);
        }

        document.getElementById('stored-hands').textContent = testData.length;
        log('indexeddb', `✅ ${testData.length}개 테스트 데이터 저장 완료`);

        const size = await localDataStore.getStorageSize();
        document.getElementById('storage-size').textContent = `${Math.round(size/1024)} KB`;
      } catch (error) {
        log('indexeddb', `❌ 데이터 저장 실패: ${error.message}`, true);
      }
    }

    async function loadTestData() {
      try {
        const transaction = localDataStore.db.transaction(['hands'], 'readonly');
        const store = transaction.objectStore('hands');
        const request = store.getAll();

        request.onsuccess = () => {
          const hands = request.result;
          log('indexeddb', `✅ ${hands.length}개 핸드 로드 완료`);
          hands.forEach((hand, index) => {
            if (index < 3) { // 처음 3개만 표시
              log('indexeddb', `  - ${hand.handNumber}: POT ${hand.pot}`);
            }
          });
          if (hands.length > 3) {
            log('indexeddb', `  ... 외 ${hands.length - 3}개`);
          }
        };
      } catch (error) {
        log('indexeddb', `❌ 데이터 로드 실패: ${error.message}`, true);
      }
    }

    async function clearIndexedDB() {
      try {
        await localDataStore.clearAll();
        document.getElementById('stored-hands').textContent = '0';
        document.getElementById('cached-rows').textContent = '0';
        document.getElementById('storage-size').textContent = '0 KB';
        log('indexeddb', '✅ IndexedDB 초기화 완료');
      } catch (error) {
        log('indexeddb', `❌ 초기화 실패: ${error.message}`, true);
      }
    }

    // 통합 성능 테스트
    async function runFullTest() {
      log('performance', '🚀 Phase 3 전체 통합 테스트 시작...');

      const startTime = performance.now();

      // 1. SmartRefreshManager 테스트
      await testSmartRefresh();

      // 2. IndexedDB 테스트
      await testIndexedDB();

      // 3. 통합 시나리오 테스트
      log('performance', '📊 통합 시나리오 테스트...');

      // 데이터 저장 및 스마트 새로고침 연동
      await saveTestData();
      simulateActivity();

      const endTime = performance.now();
      const totalTime = (endTime - startTime).toFixed(2);

      log('performance', `✅ 전체 테스트 완료 (소요시간: ${totalTime}ms)`);

      // 성능 메트릭 표시
      const metrics = {
        '테스트 소요시간': `${totalTime}ms`,
        '메모리 사용량': await getMemoryUsage(),
        'IndexedDB 지원': localDataStore ? '✅' : '❌',
        'SmartRefresh 상태': smartRefreshManager.isEnabled ? 'ON' : 'OFF'
      };

      Object.entries(metrics).forEach(([key, value]) => {
        log('performance', `  ${key}: ${value}`);
      });
    }

    async function testOfflineMode() {
      log('performance', '🔌 오프라인 모드 테스트...');

      // 온라인 상태에서 데이터 저장
      await saveTestData();
      log('performance', '✅ 온라인 상태에서 데이터 저장 완료');

      // 오프라인 시뮬레이션
      log('performance', '📵 오프라인 모드 전환...');

      // IndexedDB에서 데이터 로드
      await loadTestData();
      log('performance', '✅ 오프라인 상태에서 로컬 데이터 접근 성공');
    }

    async function testMemoryUsage() {
      log('performance', '💾 메모리 사용량 테스트...');

      const usage = await getMemoryUsage();
      log('performance', `현재 메모리 사용량: ${usage}`);

      // 대량 데이터 생성
      log('performance', '대량 데이터 생성 중...');
      const largeData = [];
      for (let i = 0; i < 100; i++) {
        largeData.push({
          handNumber: `BULK-${i}`,
          data: new Array(1000).fill('x').join('')
        });
      }

      const usageAfter = await getMemoryUsage();
      log('performance', `데이터 생성 후 메모리: ${usageAfter}`);
    }

    async function getMemoryUsage() {
      if (performance.memory) {
        const used = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2);
        const total = (performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2);
        return `${used}MB / ${total}MB`;
      }
      return 'N/A';
    }

    function updateTestSummary(category, tests) {
      const passed = tests.filter(t => t.passed).length;
      const total = tests.length;
      const percentage = Math.round((passed / total) * 100);

      const summaryEl = document.getElementById('test-summary');
      const resultClass = percentage === 100 ? 'test-pass' : percentage >= 50 ? 'test-pending' : 'test-fail';

      const resultDiv = document.createElement('div');
      resultDiv.className = `test-result ${resultClass}`;
      resultDiv.innerHTML = `
        <strong>${category}</strong>: ${passed}/${total} 테스트 통과 (${percentage}%)
      `;

      if (summaryEl.children[0].classList.contains('test-pending') &&
          summaryEl.children[0].textContent.includes('시작하려면')) {
        summaryEl.innerHTML = '';
      }

      summaryEl.appendChild(resultDiv);
    }
  </script>
</body>
</html>